<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ed650ca0967cb5d38f68c4c961dd9384c02c4ee40b9e8656934b9693ba92b47a7a7498581e3ba19a83976868066227180460f8b569e4f00d799a558db25f15804fbd46141dc8592e4a5d3db083badf83832e7b1f13c7e655aacc2f6d698065c987418e6e14b01a09706f65cbafd0b27ec6e4a1ce886717a28291fcb45ff69eeb619069e8798164d87a8aa000f413d89c8371af0439d0259ed13cf48fe2596ab50442b1b953dee7ebe3bbe2014d97d540096c36e4637d77a396db08fbfd5215a5f321c818c6d120f5207d87da91dd8d51952651b7534d81a320358480d57391fce9153dd3c10deabab2f19751a49f2cd0530956f23e518736a2c527c4128a3a773b86bccf2d8c5200946a4e84e7cb57a8efded4791d5c3bbf531c710b7c61fdabd79490ed7db88c29a78ce3027f284fda4a19e80eb014ab2ba28401db5a5d8f029db31213ee32ab450fcc573648efd98bdf0a17000912680bd0ce0aeacd3aacc92c7c9887718adf43ca9223ae915c902d491f2f7a5cc5dcdc2cd3c756100c206f52b84f04387ccc0b1f3ec5f63e16915bee3f62bc0dd5571514286eafaf8e7a1b5d95177cccd17bce32a4ab78dec63451b5f9cc5fad4b5ecb3b060be632c6ce9461f524d724b32ae532b0b32822253d2e4229cc02bb45c12a9a27d89e85a25d7504b7ae926f5fa14fecf3b58bb8d8b8328811ab7f8ee567d9f87094697eb45029d50480258786a31ef2ed1c49e1e8c435fa5d9a0bcaab03ad1af4d2bf51c1b4e1f7547d1095827dce8bea8afa004152192316afcc0aa0f1749ac6d44b0591fd61e28dc56c64f101686d068387d8055b3174a93f023444b342cd559f4476a3f20c7ad5f73e9bf9854a0ef97ec11041f4b691d89ed5c03eccaf03d3aa6daf9bc64cb24a4b2e7cc4a15690c823f101588cb94e11c029d129003a907a276713afd97022f92bc6e5c943dbf392630c977e6dc343d0d26bc6391ab3cf983a9fb178b9833d49a8a5daa46191b4ae545fb544829a0acd51874a8fa6e2d69259132bda08c38c8872407ab3a9cd3efaffae96e98fb80fe220d8e904a47977e0144a14bea45b3b0e755bbc594a047d48f7773d576caec0528c083dc3d2f158ee14e32f21c0eb70fc1b53cc0e3b90b296bd2bbc9c59d0f8fae8f93b48851f9b73cd8cba7830406d77d99081fea0360ed826c71a32f4de14c11163874d88177fdb3237fde294ab831eb820d81b6e351a12da9ebc364d004563e524f8231e9865585cd4e20967ce8d682f2365c9be42b8b909d00408289c8ef835c2098fb578bb901b613721ae47475d4251ca5f038628e6d70fdd513e55afbb5e98730c1b18e69d36bf85d793572f6288e75d24c49f6f13add0d25b88c39b09feee525211b15dc256f47fc2438e18b36d80b7e768ab4ef462f499b7a789e94b247049f4ad6a254e7f6a447bbf3b1b52e726805ec30d29e629749975f7163554e49123fad8fc384c877bbda214113a0e7340d91808f76f44df957517ae62a45d8045ac4a87e665b481698536abdb208935ed1bc79e2cd30f3e2836b2543dc6079e287cca5646387e02930f7444b59b1c1ba18acec8de1a293066ccd905b37a84b36c56666a6934dabedcaa0aa7f8c6b754ce3f836d7c72283cb917e1dd76629976e8777180813b262e57d763afa59fd336ebebddbb5f319d05312f758e7b90416c4d4fcd52b5715f94bf41b2ffeae27630ac9f1b945b74552ecdf2001a880027020bd3088a73401baf32898d1a86acca8986313feb9ce242a0ca41761b7a16899bcd30d7d89b81ca7a911e0e0833177ac858929248657dbf4740bc6d922a3e424bd1761b18da80b78cba5402b25bf755cbca5118fd0d88b777ab574b03f2b72031b72c62067714d225b9bdeac71a105966f5859f96e5312f11b6026c219aa04f82d24b6b5ea8c8305a19ace35e9c23a7cdab82e5e2a8c1e8d632ee4abf5aa9d01e87bb25ce9a4a0ab4469f49f8a910f48189be75a3bc48a883ad6879489a075821801cc8363f9276ec09480b96e900414601d1e22d0590550c693d7846cb147a57fd0a68998829bb228fb6ba8f193d0a27bfa4107e30bc027e816d5ad2a4406849ec4dd58e697c3624c7f9fae230cd9b57b231543403a8783bbaf8765a48b5d23e8b4db363616db40e95f86c973358fb4e479c892754a999a57757eb6e40f84a2ec874e18184982066c766b18fd34a293ff2b763cdaf8df6a417d4a6b8773a4943b1143672caa1f9bfb3633d8595c1256a41caa1f29b05630c2473c14b519e6ba93ef7fea0f9369e4612bda18476c4fbd318b5d79f84669d318bf7ede078827c8906e5673484f970a00d31407941b090a58fea42d559129b89f3c09cd58dcb7f7a06fefbc32ab6089abcf40efadd5fbf3f68c26055c90316976fdf4d02fce5e9a59bbf30b9e1c9612b387defdad935ccb4a42e372d3b2037763315624da922a7ae86d16cb37c70d4104650a1c239dd597d3e20706b51bdbbb094c199645def21fc3d7df4fff8c1bca7b0a4f4659771ea3c18d7c99ccc429b8cf4e0d5dcbe209f13b03b23dc460ac8ad4adebad39d9e280fdf57362a8cf0755c0b356f86e32bca2bbf795d93a3d034fb9f66aee9d1bb1357d87df216e220d9d460b062019cac16f4f30da4fca2eb41948cca40aadeca438cc7e604e8c251cb4d6f789863949a96b7959aa7b72a491faceddfbbddfeea1d34211d01f625e3208ecbd29eab1ca3f003d2ff065efbe2beaa92304bf5db22cad08ee1f8dc348d4d47c8b03f93c73e84506d0b9d9f334d892f806af8446e10260698be857211e06497b0b2592f1477c6d366c7302d71ebc7400e29dc60c1bcff79f77f661c0de559e2d4a5db8aa1876100a57d179110feb9a2c213d7389cdefdda79f99c77b2c16e3bb308469805d122df2cb61eb73ce2e6b84398f26b10c6aa1cac667c0f367adb6235d4c9d81fd8a64b5ead18d9be7f7a2821a44db03ade94ccbc1fe221b23289a557f9036020a569a3927d39b56b165eee0ac762939f3496debb018b9db1aba32c65d92bf8d111a0bf8abc4e1f54c267be35871b1cb75fdc71313e5f9e056a28c2014ad81645fc8ad15ea59b7dd4421bb3e859a0e9fa89764770029b4400e050c77ec6e830023bfb07185f945bf9788dff350cf486d51e412288ea774bed0a00b4556cb5c22b2a94a7a6d93babea78788435c7c68264459719bc3e07220699f3c876750d6bb17224db181b8168a385d4e618a3922b4669cb01a168e93415664c16807c59e710eeea76fcc08324b1aba6a7df7d832093d89c0199809604f319d9c120b8cc7600a7d09803d88391156147c870f8f3241a21f9c3c1f0705b57abe7195da66b81df04e896d92604012dfcf89cfc007cef1a43eb83b2e96fd6721daa46fb1ea682a2120e848722c8021099d7cd0b02bb12df14259b807167b73a49b87c723808df4dbfc5c72384e0a4da9e3efbf60aa6fa7f7be25164901116f09a5f722d59f229ef7cfad9871b2e490b26c2712eec600cbbda65de659f0e521312553d180d685b182269fefe8cd1e71b4c60f2960fe4d01d8c096779a8e4235d82f52e22f46448355b0c9543daf073619f4f96b85bf2fb04682918dac9da4799f889954d1586ae5d15530303b307ac1067200844f3ee40924f99eb1d10d278329658315d328f1cae9b3b76d39f2d04fd3b764a478f4c38495f717d6c5b0b2bf9137f2ae0ed7f15f4c025658e3c435799cdade5b064e945acd4a1dad832629c0697479dc3e373d562c4c0662ff63534748408710dfc1fb13d4a3473aff0faa6dd11be173f4484422ba4bb7bbac2bf9f78ac24447243c93fe6129de3a4cbe89478848824ca67f1388e5c8f47b4fe170a5cf3eada5c30240e6ab7611b6b764740800ed52260a8c977505e4119de97c3e3d9f21f2b2f39aa139200bce3c110121774a17ba979883c2c33e1ec89e55c029f36eb8d1b4d57b7f2dbe8ac80bbebd36a9ffa0faae6c9ee7b64ac3b5fa160b55be6f7ad01781bb0f5729d9b3a648d0eabeef5773ed70e0636f37fce887d23ad133c64d79d139cf7a33d8315b4c3b325a6605b54eabd82ac8bfc231497669fe02799e634508d6f606fc67fd8846f552f0a8dfff2ab52aba862b1b6cba71c32305913ed55f2eccde1cd1e8c7f118b3c97576bb68673de09092c91ebe0250767d0f8379e4a0e40526eec3cd261044413945da465e78a614d24ddd8401f30c3a46a6b318cd384b42e283ac60381d22b25745c56e07f98a9f5f7806f646002e63febb93f162b8f0d150aa331fced0bfb7349f30136e13cff845c8eec5c2ba3b752ef53b66bb21fcbab92bb63f24e6352989bec14f590895a06656cdf562c2b718abc9cf3ab3f3ceb9e2cd61d4ac5a59d4929c4c2022045f0aecf197622e367617156649c166a7937cb1c4eecae6530cd300fabe5b12ddac6456546642595bd18416ea347a196abb6a230822bc33f93b67e53a57305ec5a93f115dbc70d4ca468c5de7a836baa8b7632286b3276abba00398a5202454ae90e3895923f2d3fd56b748eefce912460df82d9a1e88b032426f8ca217af2c262293095e39bac5c171bbd024960fea36006f623df5defc41a8f487e0e9393c9375bf1700de33f2d0919fafac307b743a7b71e1a9ba6b048b76a4806afd221fc0742a6591b21b6ab9572cd48737cee4edef4c797b45442d651466ca89e614d72cf36e76ebc056d092b6b219484d1cb5c5762311311a35c921f93fc9c44e77c203db393c14baf5217a6b240945c4260e466a504c50e2f883b4134950c56c3e7ab20c04c06f6e77692aa5457d8619f8848063a598c37d408229d880735f02eeadacf0863b8f0e6fa9dfbf6cb2534927a3f337ad709a10903599bdd92b9e394d9291fc46b743644ee69846ef790ccb5ced043a4e3c338bb3928fc82e055ffb909e5c98ca765bd04ff54e060fba3b8a8f51c2a3c0053b8e91c8307c3a3f8a04de18b6ce7e238674a39844e3438e4520420ae47db9a3ce541a4bbbd63bdc8f4cef61756a0e1958442b5d4fa3e3754b0f3528ef3a387eb8426391725ff2383d3dd112671965567cf147c2698c991553b7c50c67734cb3a033a836571fd69acf669522d70b877dda38cca24abcc837bccfd0a07d3b03a5f52ea821131db1a625d5f451e8a18e81ae279fb3d158372450eb1574621f1f0b35505986492f9692ad7848947c53845ae3cd343ce061ee75232335b51ee1b188dff620efc668bf8438371392bc2acf9506821b52c32413d515754eb8fa2e7da32806f71bb3dd784b062198db8f04d307de123d07c4b23419871739a30afd4e96c2d9aed879eb6f29b4ca62bf58481211ba1acb3084d1c1a335a8de472aeeb75df7633f99f14af1505a227b39aa5189ee57aaef1ccbf575c4b2628db603caf3be28187b8b02fb8c3410aabaedc4725d74691ab48b8d798ce8e4003566fa9a11078b5a367efb300375b69a94e34c180d703f95cc26ab41186999e141f80b5a06b50593d3690b8bab84bfdbee0849438df23c8de6d57dd91846dbb5e674d5392f2051eef02ee4bfd345c9170c9874892953b5ade1b8f67179756e26251c6f0f0b53a92cbefb116fb932d7216ebb8daf23e1b2b669a7ee7ede55f0d6ddbe121675bc9411e6eca2f08121f13de21b07f7e8a801e75dfaea39cf5df1225aa3d426f04530cf2b428434749dd752837431010c3fe982dc546c26cf0afa140f74223fd1bbe9369164b027a0b2bda4acbfc83638ae64f342bbd788b1d7faf3e5fcf23f586ab9ec816c8ac7d12e4ad7c03bc3286c1b0a06d25b8400cb7f19b7bebd060a521225619a2bc30a74003aea699a9fb39945adab4092a1b3c2980865bb0f63e60d1583a623fd7479560f5077562789bb4b22d423ec91b9f2223ee63beee475d41b712614100897a6cb492809357ca2906a03eb5ce2f3f560f438e19528018738957385beb4aa15293236f41ed3ae5f9754aa73224cdf5fc5ee734ed6cf989f1fb619fe46de7b09cc0c91c40bdce7b6b9253d420016c552987d464b6f3750693554c151af074e8c573b8bfea37539aaa35c72d5676104789493672107cdbf49496377c78c0529ba1a09e9c9f74ee68d203b8dc0451735ba39e306a4cbedbdc37e0e2c210e2e18c275d42fcb63a0a1a27efecd2f555a3a82a19e584f622653fa22f92f38c5670d650eb7784bc35799f43d4f7f01f2986867600c0986dc0beaeec732883dc78f462ae5485e1a8586ba193a05fb66aef4cfd2423a04a97e3e5170da18480bbbcb1dfbca3e2462bc5032097c3e624ba6c2b3d8522c9b28bbf960b35c2418ada2f84ccaea63312520b6109fcf625cb69a21e9c498fe023727848dd3a2324411e6f4a1779944bdb3c381636e8c01ba7486bcfc85a798b08e09f4c207844af0c950a2c6120ef1208b84597297a2c91c97c5fba626e77889f32070c1b88c15d3b1b6c66e2fd0173732d44abf9fc43ddfb0f7bcec856c4f3ae7c8847bccaeec8d7a017be59810a5d1c174077e8915b5026cbc23bd3960d5d89cad73bc2c9335ab90486211cf9f3d2280c1efcd6ece0d18bb7218f066cf81ff004d4ff6a37ca2b5c16e720db477c4dabef9d2a19ce5362339105fc9746af2a43146b6f1c6b3f87858253ceeac1b4d7af62461172b662732a7ab2e913441d120265de7cf36bc4de3045caab305e4a73241cb69f82b7717c1d3dc0201d8a41a3a56cdf32b9ab84397402577a61cff696ce50ba3b779f71b14dd20a33fb1516d9be4d82fc30d7fc47905a23c5e96ac6319ad7e8f4eec941ee86120972a2eb3acb1d0944189892d95a337d0e0255f756b438df336facbb63f9c4b2df51d72890b2247f96f21d0f18eb72ab9bc8906ae9e89b099ef05420105362d0d7fb4773f5e7e546616ed96fb44209f56a4d91de32800714f14c63d7a1d150a73b5cc19eeddbd057c28815fd15237193a1fd48835b73fbd3737002373e43c85ac1dabea4e9c3ba62bd3516ba372e3511c3a4d02545c831d6ea95656ccbaca5c64c7b4a094358fa47835f1d9991a0009b3a6894af2e57e2127561a3a02d20e6f2eb0bcc3505e1e23b4512a1b63a6b80318707dc8ef34e17e070899c694e8fb02db824c1a1de4ee74e301ffa2b4711c84a387612bf1d0a8989b4c18cee1ab34e93b4f1339d5e23b9be788aa57c6c46285536a1a32140ea1f021fc516e4a7a8565dd442fd35126d8f16a913d625269552702a8346c0e9584748d0e582638a3e5f22b307a42415ff02e09bb71632fc4c48bb3961a50966f2f020fdef73c38806527b92105323004749b54a0c9d079d130fef4aa30adb43a70f61d06ed9896d1a017ad43faa95d3823172cae7e71720864ef81b9a560306e6b848303e37fd4badee170b0a3d8cebaff70d7c4f14acd17748471f993a66adaf825739df2ee9b7fd0813d0e7cbf4eecf54dfb95c89b1a25ba75c7041a59d10d4698b03530974a8e3885529b802dde8ac1b1bd7c9b42ccbe0af7d604cd572f04e9b3d0c0e0661da9518f87cd52be11d3be94aac377803146db456ff4a792716b60224d7038808fe4924ea2b14de9253d39bb8a9d3c0be0dd986db0ba8d8d26aec4390e04478145c5860a340ed1a8396380c6dff27b8333f5fdc9116398ee96aa6a1059d5f0a62f9d0e183b8486577cf2f31927e1bac3e64d8215874032a6807dfcdab1503366c70223836fc725404c6f6a41f05c2c94c683775cbbb6b9c01d4ce276a6b3c215702a73aca7185fa0dfb950ebe2d639686b5bab8ca12fb227e8f29ac0df25477804b443214057cffc43d4110e7b8de28eb2205e9993a6b030524db14fc7e8475c4f5fd502187271c21fe0b64d5ea4ed7af8ff23f0453a78a44174746b7ced31545e8c4494c703df33fda6aa1100637f9cf1226303f2d509c15d7974b7b43331afa041214ba0a60cdddd2857cf7825e4e5902ba6780cf05fb368dc199488885d1048f61befc56421ebe22d1fcb7ba8709e78b4b2ccbe72588da1335801324c9b934009bd392c3d0687d483f269f7f1664d85feb49665a1251fb823a9483bb3f1018a521b3626fd5931ac22fc9d6ee445c6a81a81d55b3f2bcfc1bdd85cbb21c6024a0c44350dd89acdbf869a4ff111ab3f35587f87206a4381d36c54d5b88ef723c6c84f1b5ff8d3a6e2c1097bfe5632c512d3d5393bdd90e84334c92bf64d86a92997250877ceace977a458fb9a11fad92199b339587f0edfb5bfff02b41f2a61c242a4d1a1184aded9f159553dc8c28f7eb27d1e3de10bd4c7cda42cbfed5d97c183274912150eb5f49c4b6e314c16335cd9f60faca091e28adf62570135419ee63eda6d8e8201165dbb2d5158f5b79d5ed8400f60f9a4b790469341453bb3ef5590193c1bf7da24c0a72ab3110f908c6058765261e22244dbae3992c1a3bff99778dd3815fae4ced0b3db5ddfe3d8b339c7c9c6874ed81d688ed1d687735f24fbff7a7eec9a6095533727be38f0ce2ea7183fda24aecdc7d9dc906ff04f5d80cd809e4aab17a92378fe13a88cab8192bd30264ed5e5bf978b9617b6cc957b967ec449af8513e6eb82c7bfbf52992ecd3178b8c230b3442dce964c3ba53fc992edecc5383bac1a784692fb05e9b7fbbfeadcbb240fe6fdbe39c1f741f9d69746eab7eda558de4c09e2e66806e2654da3ff0a987c05ca55d639eb9ba8c06a383f9076de3ae12c765f24de111c37e8e9ff826e36fac0f5427257182234ea5e30bfbb7e7afdc3ec02aab81e5245d5bf40991ce45341065635edac8de95a856069f90ab35406e0f097965a6b4133268cd438b5ee0b5a00edd03fba473467ab2654cfb1fefd8e09e228095163b20f3e529da86647af834de32118c4b5106162ecbb0813116d96d0cf1b8df09f782a4c9d96f064485cabd84c3d20e9ed9d2e783a0d903fcf7279ae78c6d55e1b8887e147a521bb969c8bad260456822d0a02f29e5142b02795cb89b6270bcda6e34c945ef0c432bc83a269c96c0deea69b710cbab3d492cf52e15c7c7127dee8e7e0e706ec57e42d9c00f2d7de64dd4cae3443516aa39d42b4bb510e5f8cf3533251b7c042fb139d0b2d69eeefbc1321318fb715f967c5487d6d28ed616cc6b470904605d473d4173a2f96050b130b8f76e39ae2a9353de75dd4a4b96618ffa318c334a90837b1db283d76bbf7ca6b9acfdff6c85be6347842bc720fb39d223e6680463be779d2fd176d0e57a45a39cef9e55cca67ce20c29d5d894da69802d33f81121f13b33d75d21259161f464c2a1f6f5e7ee184e9ab19569841b9271503c2e7536f95cd685cb54e825f2a9b776a969fac5efb83805fb016af06fdf572089c38ec60c2a29c32954546b7f3b7f253c340f1928a844e6961a463ebcf4ac25cc23d21785f0dc4af02266b128f47e29927bb0145e00a5a70ca7ae87431656c7fede5c39441a374cbfff9d4e134f954ac584e4812b567595c4a70d51d1a2397314615d3d6ddeaafa607ec525677f2f4fb6a08e566cc64a58cf29cc5f72b6b27b5a81cb99963e7e82ca06718632d6992dc5cc7097d5eb4cf705f84a9d5a849d4b2b379c23875332309cff4388724e5580530882316a6a68bd4ef8e07c08614f632484217b9a5d5cc55b0a70b04e2ba5730c0e85f24c63c7e8f3ffacc9db69726c9b20571df0b8a28e541e4198656030564258ab4319ab932c62de2c9f4cc19b30a979aa37a5b49f9b8560faa9c5d3dafebe3949c99e1f5ebedf06b0a1e93d8e910b5f13fc4ee380495247638270bb699a67fe83539c688e013bc877bfc78d0420f65255bbb74d1c34dd1a37ee4a27997b36e845837a8c0fca62e395e4a087a37638c7974e11570cbe38ca77339f780e66bec684a97d1d8793d45c75d2def4b5037f50e8e5816728ec957478f1c5536dc6df6b509170a04d7cbd3d58fbf84b1278eeb7549549c70a86e636fdc5b50cf721220ee8709cabade6bc4c2d39526865159a2d0e3f445aac612d2729d1a7cab874610501d01f041e8709f07033e7c91386e352a4562edc5bcb5ec10bffaba32ab51ce3b49b0ca6632f1951e3dfe416853898139a40c43ee1fad6553f2c0ccb0b5d923c7014b86fe59761b790dffe90e43ebf2272c9e3417bb35b47a499262105d0f17c8ca51883372f7c8adcbb38776ed40b6f56431ec9c109d0d2f12a1acbfdef243f8f900444c15014fedba65bec56803a08f81fcd9bc379f4646fc37dce5eaebd3d4ef9a85f84fa0f3e16fd4761f3c32d31b55cc87405de89d85364e395cb0cd5ad8eddcb9ab98b557dc25b1209e07d82c78d33ae2ec21343cf0f206bf9d03f5207f19761e94405315685ad55b5e883cb2e237c040b47559aa29d59043b8c983e7787ed36d20892fef4f701b3e76f3e1cc1a0965ff1256ed7e5d5073e0840049d7dad6ea3c150ef07253e1d8bacb18ae50885a58f5331ec7e2459ac10ed65bfb4b02485d0e4bc454eddf78eea4661cf6c55adbb3722147fb9e7db9828146b88647acc5750f27204dfa94f0bc64c3f2fc11aff8d7cfd13031eeffa87f2e233b71ba750fc446c632367a9c2fecb8fc83483195b1470de4629017ae91f24b8de64f3bc1f82265dd88e5d01dbe82ae421bcd76c8941e0b26852d46a804100a4e15a1ed8925aa40fc30c77757613d609fe31a1714dbdf01337adba2986fa2477b235308855f2e9287f2d2656475104dbd00925a5d4f4055c53768027229b5e65c23cc77b16a2c5b076fe54385e13bbcfb213a859345a77cf1fe4937049d327faa0a35a86c01da9dec868a76905da3f46de8054ec00f468681048e41b1e92d3239e832ade94c37efb5f11bfb2ee58fb6f4544ce0010045c5aff035dd5f2639c7e2d671be3626030b5b79ec189ba826931bda59ce669dd54e397d5763fb94e025de72b98ecffa6292f521b8989fd27b61bf7783d1e8e30bfce0b06de6797a5b1e6af0324ef02dce50d2bf0634cde202b919afd5c94730ac9cbeca86c82ff2d1a1eb7b16b265b085ce0e13f63fa2b4686b946b5b74525dc851bde3d8fd3ee366a9b8ec1c1d6906ef3fb5ae6427ed05b57b28b52cf5e6fbc94baae08cf30483c52ba1e82bd18c902af6339bb2cc4556c7f6a70e034f296cf8983c87b176293cc59dd8d346cfe46b99f353ce267c0de59d1236f3566825c99e1a5119aa5bf5252f4b053acdbe8b6eb8a215d09b11fff015230aa627cb455814f22937cb3011db93664527d3bcedb18b02c1cc66e76b10f7e83f66b35c44d90f09c59064edabe4303344c9ecf5f2407d6063014a4af7d25e21cd9758b757c64e76799fbf521e50cee5290b1ad1ba5ca09cc132e24ba068e22f9aa937f7c8dba91be6c33d3ef761e2da923e448978f5492fd56ff624c581fd3e7bc7e4d79b93a84d47785a231eeac9f43fdf5325d47a6aa0702251da23f61f008d57137d70b26b2342fc711c808c503879de1fc22a4fc58928d6999ebde516d58cf961f67bacf41ca7ed5cb6b23ad5da345158d52098ebc1f13f52144eb64c099dcd4a23717c8a36da8daea766f149bc130eff583db2eba6bad5175a45e54dc029da5dd3dbffd43a60a6806e1a9adca045c5af1e0f70200d642cfc18a828249cfbbe76022ab9f9c27aaa0b82620c157db7d4af98f00f0c073a690f124495d744d129a16884e2c2d463855c033cde67b3c8326ba0652cb94c631f19e47d515d4a19075350918fdd309cae3f7e3bab90d387eb3b14be610b44cc200d52e09b8e372483944a6be3967e3a1ee106a3b2ffc3320a26199ea6e726fbb9a47a03c535f408f6d4166b44e06933fc63d07fa8c95dac8ab1b21af9bd1423ff718a7b73fa915e0c72ec22936e58efdc08404dc1ba6ba7f3a18dd72a5cd61399b30c58d3107501b7382744b9dd7d4f37df5c16a62c37a846020cb067a8229c964c88c476b7d0dd7f0e286231b5f173eee3a17ce9a14968878c6d5a3b818626263bb09a199a91cb1ca134a76682f818ef327734c4c102fdbc1cbeb91b7663a6a0cee806c209c2bba9c45415947dc34afc6061d86e799a95028b52bb0d1f103cb373a986df1af69034192897fd84a544aed1768a173f9a584dc48b04b021515f073ff1d811d1d03a491278f1cfa9fb93e8d45abf8ff0b0346180b55507a8b3bda93c82265042188396304acb62dcef3731a7857d6285a2d3351989611b6a806c5b948929669f36e98986a4478be72140eafcd5931b052f42a4a7605c823ddd0cd787e8389458548dfb77d672f0b87426eba836d4ffed967ae151b0e42edc0fd6a9631431c72e1362b461e5256a4825c69c7119c57c52d6d33f68f2076e715a8417edfd7bf1f26982ae00a0d3f05845449a4762045be9b23d05e75fdf80d5ff8fe8d4aba43590b972424fe1778421fd79b39d55b03b3ef26862f5dc1b569405fdcd726ae2701ba051d60dc89982790c1bc782499d94749704e6cad121558438295f2b2180af23110278760b7a3f94721628386c35dbf765017407082b59da66b64670d2ec0473915ddb1a3fc35cf20ba5ae0fda2cb3931d7c462a478098ea681765e345fff37d31f9c35f506c6172ab21ca7dd77c83262b53c7c35b503bef2b3d1fcf3f817ab03395de631e0d2a6563f7bf3b44a50bcf439700f3750514613bb72a820a14124857c76c5238dd5aaa9183945cee52a71ac6ee7ae4f26db8835b0d596f8d8e4abc57aefc1b72a89fc3f2077adb8883414a9b9fb8510d5b8636c6570487b3581c7b99a4fb6c81c99bd885e3b6728b497486918cffb7ea231cb065ac470654a087a2461aa87563f09148264725bb502b1687688ecba2d722b538c7442f64ee6b27b865ffeb8b70ab8b4c2b81a7e3d05038d4cbf8c0162355d0c555ef5cd5821fd2fd5768fb8c0b3ed88f115396e00720091442dc2ee460fe16ce46e7edcd78f8703c6af16dbe5a065e4362f65f9c82cf15fbdd6a3b4127df91773737c139aa70c781a37c1882e9cc3f233f545d5b1bfa53740bace209d53d930823f22f94f797f7aa5566616e3240358626e4e31de67e6b7a87b51bf78b23982d57ed1da086d269c9524ec0e401aa70924efde3e71bc7617f7c3ac4cfa8589c69fd1f4252c8e0cabc2726270915bfeefc64546a9e40f53ed762e4a8a372313cafe4cdfa481ba3e264ea803cfe4f13ec6ee9546d4b31fdb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
