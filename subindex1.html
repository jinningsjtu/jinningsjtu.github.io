<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3d838df3f282c06ddb9e82a107f351cc9192f60b4ff2400d37fd73d83ba6434b4ee7df3e9e9f22fc1349afd2a42e986876fda3f3d89dfe9d929a29997ebe973998f16a0e29898096a524b4792985dc09689975be585acedfe55566be7b66c7e3dd032ad57bc27ab745f297d5a626d3bd2af26e9ce971ee89d75175d5f0949861ddd4812e30b6618c28700018f51ed64e4bb5d3919f4f480cd0e48f9b448eb7810a08abd4bf87643910ca21080b620f9ff27ec1cb5a3027de0f054e45b2c48d944b9d8a310f617e0ca1400f829a146549fe2dd497f63ce14ce961f86f0d671990c9a1e72888aeafea2949d65a9cfc68ec4c68bd04e1518d4af9b982e99fd83ea60df516865afc689ff6336640588c3f01c864c19f0349f0eb3c1cba3c15444aac637251e83000cf245248a65a82101a6545678a8ff5c562f5247b20055c4d081a5ed07803f85c8bc2dbfd89383a2d12a9107aa8b4273ff1d75bbc2b214a25ef580f571d801574587f15fa17d9db6d2b25315c723b95590fbd6cbb4824aaa164c30d0e4d6aca563f4acb45bc9c629563681dd1b77642bf09622bb5f76430eebda508d1ce3bd56b4c29bfa383fb061eca7cb8b3d8c611ec72433455b753a62a38d758120e6183daf043afba054f79bcf825b9f3b2982aa6f32fcb3a18e32323e4b43fb3c0119a0d557cf776463b8b141a7298fb33c68fdcf57e7e9e13273e0b5183ee0cd49b8c13f970f7dc5983b310784023a5f3d18e014a15aa2bfae0f036b668048ec9335859bec9610b7d1bc1a9f83bf670d1f993f774beb49b1ea519d6f073142c2a792d4b2d1c6e7fe1b9b2c69fecd95183c12e83424a5418b2da2fb10643230d45ebd0d720e33c8b8b99855fbab304bf5745b0b76a40b86d99d6f8d7ade3719ffe5171aba640f0f21db34f7b347d25f083d519e3b3bccd0dd0159329d719e3275e4a5214022e3932607f642b8103b882c5ca3e5ab52160246441c2c6f3df474c86daf58d78244980e58b6d300ea67136e38fb676179b6fb17f0069a67bd25adaf70137b10692eda46e5774ca2b8857f44e512636efedabcadfcbc42afd27d6397f3f1f6203abf4628fb9d1f7799d1c7ab7b0ba10cb43e56c7e25071fc13b1cb64e5d8dc922e74f14a11b50a09f473182551d9828d6f3d497aa1dc47ddd320da6eae196ac4a696e4eb6faa220c118f73a19bee6fd6db1fe2abdcd503b2581d3ab4383927c0b416368370c9da85b8e1fb42d3620d0a05436d08e516322db8d54fc27ef75d24bdd87065dc95eb279f84c7f3cd849b8512fe1760adeb432ae893e96d18164cabf89a7ec7e5b11edbffa71b6c7d2701aa0e2b753853fded60f306e2c58e8ad8580eb50b3cff77ee6f412c934f95b9316deb4464bed138a7248db9196071914cd370a94510a1114b70638e69609adfb65334d5d7fa8284c885b594c2b2215e42096c1b1be0c6b9cc70686166fcf61b0695e5ab48ef0abd5e94ea808143f24f34f0d7afb1ee3bfd12d83210cd72ce568703f9452fc54b59e370d905c7cdcbdec4447a2bfe12376d2daad885f45ac982f9afa3be90a427f5530ef2498d23c93abebdde61d8851e48b2c5df19a5a8fbd44dc91f7ce84b19809cbf8b48c1e35b512d5f62ca1cf498466afd7ca6da4956e038a9a520ab740742ffaa86d1e4bec9a272ba580dc11d5427805afd90210048a06946d649e358b83d9ac8a4ee485f9b22fb3eb3b519eaaef825bef4e3dc7b9b0a1ff27aa9a62f5c54fe3d1403b374fbe35dd96182c5da8d6932f595e89b3b6f7e00dc66fe36107fc79daba9133e7ae2d0ef33041ad51723361e81cacc451c918a285f01d8a8c4486b393886e30a8420680ac2c1aca6f14113c9d48f4b62b3dd195855c74db4c5ab390a7b539ca81b71edbe5a6281763916f686205b7e95584a7152b60aa935c89052e7fe3f9bf85cc0641e12b3a052f7fea543626059e2fcb972cd7c169520c7f2b7068c316d43ad58a4c806cd064ca71d40009cac138d7a2626518915b1397623b0e69a5392cdad7b26310a40bfc94f7077492966b3fd8084cddfce66724413467d0d81737624d0e7dce53b48e5ff7631c18b397f8a98fa6ce28e7874f78f3bc430c15a57b02213be30cc677ad0186ba4ae93f72bf9f7d9f99ff3d213092d9f94529fe69e5967fecfab567c3af14d0ec27ad7f6dd6bd1025d36ea99ee9c1750f38fe58b3a92e25109afaee289d24c1bcc93c00993b6ad14d8232e6adafc257e6659d299fb25ca7b3dc74330797adc4f08766d109e7af9f388578abfad24719044ec967ee7ce92e394f9e01e10948149bbb0f194a3fdff80241a55aa2a2885ac3df0fa988f0cce9a5932a9a7c16b3276f2ee48036ddc6f16ec77c329c6ab492b7f6062ad8f727a55f54cc1132446ebc465dc1c3fc37c041a477dcd1a286f23eb0140630b0574f761e3a08eaf261d68daa358928098d9b0a63fb5380c983763ff36af28184030527d7650a2d9913916f0b74c89c47a9d593fde5fd0181868321c48c57b9e409f9e811a0dda0471a15989b19b98c65ab2d4f70343b832477cabc17ab3cdc921c678db284d356e28ee90ca355db1ac7a916409c03e50bfc8726dce3d049ef31bf9fefae8534a9e8eec713f4b127b3e223165bca35fe5f0f27fb06d585afed1e86ab93067b8269a147f73a0adbed28018e5ac3c54232e7ad8ba9c0b9b6e43a3a7559401970b8d95aace49fc51e55aaf95e5101d7aae53890ab2961a73438d751b5ca419a7fc16398085102982b2e3527d36c651c24ebd0539ad47377de32b21ada0ae3027db1175a7ac1b85f1bd24b2dab90cae19cd86aeccc3e2b9369de239387779dc8d7f78fed2c242dce7d14cbedd39f87e5ce930d863cfe7e057b8e188a12b8e5ff9da76ee42f2eba2fdcaa44f837f011e90d6affbbc5ebe60bf2bca3c31502db78f1de8c338f9bbd51be0607387e7ae234c59b62dba834f09c3615334b96ee2ac1b56464ad9185b6a44cdcaa865adb7e5974592b707f534624c376b4d7b4ba9e1808311455cac138640975c44760dacc792a2c673c0a1dd948b3c4d68df51cd0dee5a78b705c346c134b8d7664a9318517cd65efd370843bcb1f4c19b642a3c5674990a206a0ba62673095ef895de24ea9a6a541f1ac73c7bec00ea1dfa98317bec9aebc93cd5b2576b89732df03f0311190e255deb2fa4029e6de784f8977084a62be6629162adf0e6cef4a05dc3c04993dbee81448f24ca5522d8858a62b9be0959958198813584f52fac39d3c7dcbe1db558a746adf38992c6e37b0021c59bc0b128ea1818096a9803499aee8f0fa4c9e8f3bc1ecb89215ad34ce6a97a406cb9eed4f6767520aa005f2eea57d3190b6e5ab757630b49418b00f3cb3d76bab77fb32aa6d9fe470d3786501eb1ceee189bf59f132057af940da453c064d572c41c1ca12687c07ad1af49efd5a3463d215a0c62438140ad0ba7c46eebbc3fb81059406bacc34de31a3a5d98e52f66f82bba15954d3c5b2439f367b47dc3218431f4159be65ab34f9fa3eab13a1819ddb652e2e04a6b7c1c1f3166534dcf5a27c54ff16e043da628101d785444ff7a8c8bddf088c8393cb1207d88ee5247bf4576ea6e299701827f22eaecb6e0b0e0673ba000058833b78e43858229733f3c7abadd23e69b7e80ca41892be58336f1aa9470d708c655570a2bcaa4fb09ba4b58288a82e53bf97835a27a64a5f0f043631c1a02ca399eef623d969d50357da26594638d482c4b11f99536a6e46d6d7d7c878ff703fae99c0b17249204aa7ff890fd591070918b5b0d7deba898bd021459e7ac15ded346dd78ed95689293efc9015fd38eb17fda0046e2fc63b6d7dc1d4ac73f0fae820ffc7e91b5528f65986efc372a189130e54b5a8c58c5a14de4f590e87ccd8c504386c78bbf7d68939e66953e9ba9035bb5f39d23aa5a45c5c8a1c3272d2e249e951bbaa81a4ff76d733301708dbb2e5c573c19d81a103914c238a48f7727cfa4eea087da58d008c408fb34c195f123bf5c5a773382a01da5c9e978c6cece5b6ff464880cd66e48ebefe17be8c81d811403c3822970bdcefbb6139e1eddb5c811b9e9d6e74532bc03e9e075758d012e1d0e61da222d5429a3b3329708cdc83c4e11c7cc8e4d34000df930231a2f4beae257bf517ac80923e46464c5f4455d1f770d1145370f0b5889e08c1ce22bc865aa036cc4cebd6641c922d11b4fe7a0fabf7e6c7b10a3ff6a08104b48affe11bd89c2a134f1d01541a805b48e1e56afb2bd915d9f6f9112249648eb6f65dfe6f5917fdf9379902b4045627dfd505bea17332669cdba1c62590599d5f0ae83d1088ad243540d727203dd377482f3a0a1b99efb36856ee474b69fc4beb2e1f9fdafcbd44e7f48430230a82f503e06f9f57763cb65864bfc53c7478c13650946846fd2b06ef025430b85e6e08b2ad451dbdf0f02b39abd927a283fa74557b85eef965099960867fc01232ee672aa20f3ed6dcc5ac3f318e62f7979fc06e35be3efa85f17ab2aee73d0826cf717c4f20f4f9b43a0e9d648423b3324a22f41536388248a23ee2248fb0de572052bb30a4c7fea6d18ae922b798000f458145067497d805b6dfa18b8e8d20a9a3494b735f2759bbfc38199c56ac27adca6dabfc9e6cdb53de036bc60e41e45a1b06fa64b5d4c6f92d7f01826844a2230d7fc83e7b4511792875fc0f82339fc8f4408a764329e1040df651b49ecdd29fdabc2e6125ed82a26d601da82aeaa6cd8db995e480c784083ded2bdf17401c54894500eabbd816eecd93a8d4703ef90e4bd6de113f027b4d3805963f8e08ef3d14984760d2ac967cbd72d66b2cc14275a6dec4800e6a59dd31e92a2a7a2e2cdc86f34a16094a10076955f33d8e616d30cc75eca07b03e85940cfcd266d53778c070abbca30a9c672f7922b755f11880976901657f1c0baf31951b32f86ee513271a295c3354620ddaee551a5d3f606fad5b086929a4438d1b66857a659ea3898e1611ff3e5156566760efeef750947c0039202d8bf4439b48908d702bb579b431182ae3a0123e97e263e4498ffe9e4c7f9f08c49c693c79c6623edcaa06bb050e1513fd614c743ce918828ace4e9c0f098b268b0e64c988d25854a40d09c6283157fb405a2cb2b3fdc757df20e3e9e3560dcc3d418494e87c4562abb3754404f29b7a2a20640732f84830ef9748df0beda737f7577b0473c0b920e1ac328eabea32096a314143441148b7d24fa1e283c6903ee8d4af8adc664f245bc4f11febed8ad5d24c911deb9b4002f8e605ab47d42f9eb7d6f21e8b8f381dbb35051e3327a5cdfc637cab8337a0abea64dd45308bb89a35a4a9777742e5ccd0bd84b055447c2a9df558cc32e8f1907da00be1b11afe7b3f244549f732021ad5b7ef5f818422ecfa380a9dd89015be7d5126bcbbce11eb02749477ccc37076f3074ff7b97eb5f51a8bec341101772799dea34573c06a354e63cf189b2b862c80ed32971d929e21e9ae99849f28f106ef1b136a119672b260ea17ea6dad0797d82410813139eb93591671c46b84497597f1c2e7f411f5b4fdb2beee21ca96fbacaa0b7c15890a60392c1322bea7f30081acc9f5fb4624e7909995919c65e2ec2ff503bfc5da66fd710555ffe04494bc2f3df537da5d37315eabbf6a30c0c524356250f818a58e639b2d6174f57a92c1dd20cc792c39a24218295d264218953bf63dd3b8cdd79fbd323b860833710b444472f4113dc84416403b8b6c1334ae6e807396bdbd9fa8c772d301a9875da13e2098ab8c8ee7fdacdc636f74892734aa061e9df0c95d0fb5976575bcf2ae36997f59fc20d6cf53f23bba0476a54a91d7394176d00b0b9300ce813122f78e71f6cfe0290c6f4569799857c194e00d3fa79166394a6009b6537a426f9b01a13a35960aa3eea1dc1b72f1643f37a2b3a9fcfa36607a117cd6835b771d6f2dfc4c6c24fcc6447107357979daae5d6671459b9391f9a94536ad695c994953267c4e9db57d256aca84e35bd6b9f1ec98b0899a687941634b26f88d0e33c3d367ae4656d385ef291595f3687ab7241c49a0aa91d091fa4a9ca45b070599187d5cbc886942e3241cb47ede4d56d00a53c62e999e42b3a86abfa48357d7d696e9277cd15a590fd08215aae59878d0434f422baea989dec37d0a5044f24dab9fa36649bf58e9906d29ca75ac9511235632087ef081895be7f696eb3a75477ed9273916d9b52cd893f01ba93d49446de2ce88b212383990b1192af7af62df88973a83c944627aaa844547ce1ce5bb820e379d143fa0ac7fa6ffe59c18e541534a30ceebc4a9ea6c74b005815936d4cb5032ae4fee762ef8b20939e1bdff45fd0d19d7680cdda46c8a761a84523ffa30ca1e5332e1e5af99685e0523260b19778d992189da5cb409aac1f0e0ee10215b227ddbf3814e26033832dd5721a448bb7c58991af47b7f2792fbadf031fc4fc292abfba41ef6e3e88e36001e8ec67d9858f123d91d338af90ac95583617ab3b1bcd86e1691ef9f663ad82e9028849a7eb7d4d9fde2d4e37c772ce911acc8ccce1fbf83a5252d3932e635d08419fe58cce95f50629de79f9d8d1f969c1d18f9a8cc8fb22b5930031039933af8e7140a348b419b93947373fa0376ad8c8e307dc8d85f4daeb1d930e2abeb66e7db736255ade092cc8c1993ec7a49fcb25ddf732d737d94248427677bb2d7ca4b6eb1a07d4351dbc565490cb1cbdacd73916bc971aab0d40c0af0e6706b68a1bf3b6ee72ed09f1d75892660fac5efbaccb818dd4870ad2f752332116bd02bcefd6f6ee7464a8d81084c11564d7252a167bd73d0fa5add96f329403a2af829e23a7b9cd973067cbdb345d2e43966a394ac5560f0a3fd334714d6ff1b0716ce8bca8caeb13f811576ef1041e8f8e0a176af4444099b724a390e44e5f22d205e40183cb31480d3c58f8df582bb5c9f6490f23d699939e91f10d4a558464e6f23a0adf3d141a119d1c82e5cd88e63efce1c3ae212adbd2dbbe7455350f919c102ded45bba9a5b7eac2f23cf00014ba8c0c10aee71e8e9ada89a54978d2b8be94779021dc43dc70ef31b378a9a43d376af5b2a1a26dc085f574a4ca6a20a0902b926d3642fbc8fa9de8329eba2e22249dcba86cc2dc72edfd1c279d627555575bbbcd72598b7307c8141f94e979d773333e5e4aba11643790fb69cdce724abb6bfc1cbd82ec436ae7d795ab48837689c229c743de8ecda404e93691e0721cc19587b71c6193919dff2f7d2a4300063e60d445269d7dbea73651c1093d76185dcd174616122e7326549bbdd0fc8b13e04627398f53d30f72149d2cb07f420d9e244d80cb48381cc88e41ee3c26f1c613886870c422cabae599402eb7ca411edf59dc6ed0f181d8ebfc3974819548af095c7d8a26b9b1c61d478aa50fdb28e0a14d21bbecc1c7051704a4cad0f10085e9ff3fc94b58d2eb4403d63c24003870c6c3c53fe5d16be1af3b50f9e534d090f72c09ae1124ffc5a1b9471a77c414cccfa7434b4bd5a628c4a0201e58e02c3a29f53cfdc35775239016dd23f86dc212e31a0c618b49b5fd128dbe3f4b5cbcd3aefe85c5a8af2aca8fec3e813007c1c16489b4ed41d470674810915df3a70550e9992d9bdef5d260ded4874f8341b747cef9842a34fc1bb5cef4bb6485ed149d5c9e87998fd3e1e1c2187cbd217de45e876487a4d0272f2c327966cd580117325b01de72c47492d6999fa15cc8bff0532bbbf139ed599a34c9ee86e2b05c0849681040ea38be98e26c799dfb3c571acdc84e862cf9f6c6c8e729167c0f5b90f187a19e8062a5e0d2adf1a4a7caaee3830d4032abe5ec9c75691a94ad4347776f27941dbcfed765826569638d6ff67dfdf8936537c401abeb45f93cd8249f5b5bbe5082865a476e44f48f709478d28cbfe4396a90df6d04fb7cb6e924c62d9d2bb92dbefca9e5a30613abc09da5c3a683d183e1d20e0a50fef661d91fc8e3f8396a6416db52040adae1a290922737f6168cdf91cfc32bf1f000875322088ded2d5032a14d661ac556ba2d747bdbbe04a58dadfaa872b893c33faf9e26f98df05285b9d6462c8b47d3dee0b42d05b519d3bceb6bae87a03cbe0d75665558be9dc6f5ecc257b0c1515f76d5ac59be97d3edb623a7f9b68ee5051057e398222428199a48499ed0fef87efab0fdc8ec2ebf2894c940b49d8274f475d9162255886305eef88dabaaff4bf7d26bf26314443e523cce24d95539a8cd634da74c616f5cfbad5afc62b6a20b07360e6996b448e74ca144526bad3d55a720063d3cbf098c9e85b2664d09f6bca28b6b5a81f8ad87c3f942651d388ff18a777dbb7fb5a089f93c95fb757c37e12fe8f412612f7a3c958604ae0700281d88f573429486cd23853c1778b27dd995b7e367d199d9dab5a2e8c75e8919f1519b57e15b3c3ef7d45310025ae0de2b40e1d6de7d193c6a8f08dcb92c598e9a44a7546366f00d3b3553794b68a00e40c5c8a6f3b0bc1f433c3aaac7c9226f4edeaddb05723139c9e557a4ad994d2c22828f382b8d729a53cd2358e8cc4230e6460d88c1f3f3f8ba261184a8f6c117cc2a4f50a1ab83afc39c05044f08df2896f4938927e8cb1fae9b1f3b0f62c3f85d311e6230bc4e62f7b8d86bcfd6decec857116e3e1fec95e20af70501fe8a10a1380e041b6eb5c0ec077e0899daafbccfce4d756a87963e1dfa2eac15ceea32d699b67907e6999d4158ec66a15844d0b372086973fa878dc463bc7c1f248c039dfef1d536403804229d070ce6d6b972703576ef0125ce060e9e30a1a97c706e1dd9fc21170a6e59189d32274633a317c5505aa553db1c20b5a193b2c963db7bc6bd4e50dc07cf157d0ea5a44fba72f0ab60077d21ef1c5ed2f833785b13f1137eb766ba03022eeeaaed9993e1dd1fa2860249c96a93d149600bbd8b2490ebf9e20b6c2746008ce14c9239fe049ded2b30cec11f451c36a49ee024155f55d847af8b082ebeaadf3dca6c08ab8716dd3d3c2169945284da717724541b6d6faed7155c17922d41e170a09f047ea7d3a0a62d2bb32dab00ed643ec83726ff164c2a8f7747fe360a68997ce8faf16b69bc07b1eda1396cab196b408d837b9393224e8580a13a600e72524b14292c177ed1ff92dd0aca99d75f7bcfb59b4e1c26537beb9752433a65043448d53a5b49ba1ae4dddc1ab28497f8bd91204578e09f0ca1f1d2c9430ae87d5e51a51391bb988b827c286c4089bc29fa1f09b8b9568d2b93825f9c74b69804422675e87d5b312388504df2958034ac5761e6eb972db4cd0d214f4bb7b2dca1f52819af0975e36654b761a117ca03d44a1a077b8b78c1d20beabe258286719c8ccd1a171dd66453f1904fe4591b735f8af96d3f883c51a2217c599015ef99b7be35e37a95ad13aa76d1c9e38464507904381665029e036970e66d4c687c925bdbdddbcd4274bd73e9c19c6e509a92255996ae4826a4645354897eeecd261a052101fcb0ff4856f0aaf78ef03582cd143af178ff65253c95949c4cdc34373b03452d205d336c2749931e44433de87ffc2f42caf8143b66c175589f9c6fbda1639b2d81d2906c503faa0f5206c51ddc161e0f7ecaca9009fe6dde1d4a5a5651c13cba1dd3e2070fd8de40ff52adaf12b5cb705a0d3931dadcf5cf15bdefcfdf13e7fcfbe64b7ae50d5eaa14207a6055ebee64ce8235828f9f2c9c05286caea36e9f87362ea9182d58736c30c9fbdedaee116f00e10abae3e953ab62ee849595651531ad96e222e0275cee19502004e1767d8a29d45cb559e40bda9664e67d0377255db94ba6149325229c49b1056a7fa694c3aa500b8f32e062116b97e5b7f5f6b161b531659fa4abce563a69121f72a1332afd9923132e1225f660ce67f4afab4a25567dfaab062656b755ea77f806bfe4e579c6b2e89e11b09ea5da7130c11cefba73592edff078460c928106db222378473d1476fd3a768663c132a19f996334285d3700757ac38c0e4948c039fd4ed2cace4c9174c97e8f7256ab28029dbf5096aba77c304e45f3375dbc6344f506aad9442478f0f5992cee22859e8a7573c58aafdf68ba7fbe4f08ecc0c6c440f07b3082ff7afcf910486df24c634c5c251f3ef88cdbc3a0c5f2211e5d3a69f7d57d03f00fbeaf5b7b10b04298b9ca53d8866d1cef9820371d0dbe36c9053c62cc0219d3cb6b5efe3ef14b1c6b6a35a62b798c43434f854ade4d68c786726f1f7e58629726e09c376d40d949cdfbe3762f62469f23cdb1d0ada4cdb2a9b46fcea58bf449bf1998b66b16335b7dfdcac94a119c22431db454286410edc125ee1ffe50a9414ae16cc7b44e9f67050b6d45b0ba4596aac166a031f056546b6299da9c2841d3b23fbe102b42f280b3adc29ae524cb5a9c3e690394e65c96c15562231af9d629ad316f327c4c4c9ba6a3cf659144c440afc8e5ce11491bffc9ba3d372696276633414bd7d087875bbbc645c48c2b14d8c576632960a70f61d106090631e82f1b8eda14b19ea6b8b43044fd07832445c7008f62ab300cc91f37178086fdec4d99106b331b89f0b3b54229c7df962c90a7d4bda81a12bb222cd0fc532a9edd5edbcfd40e7f180141e8fa9a9d1352d6ad477cc3674ee98754b56d9dcf35c6361b409f2ed3f7393fff7e28266a0adf4196c9ea02103c88522fc6e1d6a393a7a4d4fa5170541567d0b3d6b8d0a73f944e9ebc778e18d5f64c8a683fe47bf6f82e300e7cfdba79e12ad724e8cb16142ab549e3984dfdd328cd51f3f3f658bdf301e05ca49ae9074bb49e4ac799c1dff924bd171077dd0cbcb117203e087a21394adeefd4f200c0d864f5c6321427c88c9f46862681e166a61ae3006bcab8bfb43998b8e6764397646370d27e6645a7636153699511a94c0bf61513604e90e7b54e02187a4832a69e5ee153f062a9e0afab13c7c2e8588f79b032611433bcc085c113b20d2466c2bba4535377c41bdff457da950beb6b4d8c2cdb9fc59f8820548981a56bc726c4a43a19687ab212880c5275b82e65790e32d8908b90197b5f36b99e520d2850a1d38b29cbb5d9d6b24f6278663aa334f0e77e94f315de10a84df05287f5255582bcef26dc36905b40e45387c97566df21f4e1ae02fdb7dc46d7015e1ef7b5b6b7ec7d7927431514f6179899de63ceef2d5312b34fc68ed1102dff89ff115787798ae525954488a0c70adc525a0259364231367716a7165c68ca44a226e37814770c9bb9be0de491517ae85ee7dfaa64c39ba7fba8b8ea8f1fb4499fc4fc2aabe45f3497ff1f7dea7a96313973cd781f0928ed716da03a44133fd2fad3420133d2a1fd8b3f0157ee0210798746b30d40108eba17330365a625edc64998e129722a933fb0627bb86fb90ebbd7f5b1b36fd9304a9fc0f56adcaf4e26b2f3a0d8b9f70ba1d289c21dc82a96ab308fdd81a0d172ed57f6106a2d403bc3bf8e7c8e7512ab9a2ad8910e84803896b19771e321d794148e968dc9d2e818676745da848c5b07e0562a6f250c01c2ce41a969b0966554ddf1ae1d5dafed004a20992513927695f12551409b6fbb4d0bf574f34f6efaa2b9fa7937c6bf5f95fba4782e9ddebedf4b8640b6ea9c1e977a6ef0ca98d5a58822462a34510d94cc694e5026d93accd3924bf8c6bf660a0c3f402d5ca23876fa56bf770f10f012bd7240c19e86bbb6b37d07ce7cfd3ba50434a8e520aa4d37773dce189a871f4ef8347f5761949000b0ace3798e30d398a20c6d1e0ee96e677e221bddb1adca1087e4aa4b9e12a486ac4349c484661e74016e2fcc9f94893f5d859682859172238f0c0eaca0e8207f033bc8fc8997045720a785eb8fc5940d7626e7568df7339114dec6f2e0f1f6a3f55b018c77334f8d7816b3514a0436e0746df91772207d862269888bd471ef6a191cdcca50ac089e5a10a5b6f92f1c33971e4063e0bbe80ea5021b34a4d45fc7476dd9baf3fc86fd9a2e9e4f7e3b5a6109e2b94da3d18e83fcd05820a5225ada0cb3b86852d4394b9c2c5ed4039499946f3421cc6d151213223eaed2ea9309042d278b4e022e27e38025604df9302ae0118404db04b297b795ee69da06251c50184f5938664419f901a2059aa83331fedda40062304a8f9a29f52e6903fec90069a133249d802440e4c49dc26b5cd14da28089216068caad3ebc23581bbcba061dc1f4bbc471756a48197c0297cc9a9d1b830a71ee7ed0fafb620b09f01f9c2ce3ca294f08c354650823ce78b6fcd3f9e808ac1c6d1ce2e67997c4ab589ed64169893e5d3434fabf351c617d6f1c937ff1d56f1d74da6de5495eb80deb96ecff4c668837e3115fbc8479f93eabeab7eaccff5862b3f6b687e99a1cbd44ebcd74738ef6ab0f1777985927cffa6a7108bbac283db2706206f9430717957e9ea968daba5d5a523a31aebae92b3f0b7c327b9bd30602abc32db912cc4a8ec117a560243752ca8bc1fc452be284c4a7bfc790beb8657590931da7ff8966e076fa5ed53d6e2f817e6faf7d147e15e0ef6223c7ea14eeb5e2ce8b75ab400ee1960a8f4a2dcae4cecc66933132c091b7e24ead7243295e7b77f1431ad83fe927ed3361cb14a7de3c828f65cb861756c38b340b588a99b40b5116fefdffabc790d7708196d56087cc037cbe264361f8e1705f1a07f2ddcbfa9ced7afe5b840facae13ddadee83b67523a3c66d9164c74cd9db8aff8d1ee41214bf852eb9005ab5339408b78fd74d4a5a060c966fd8c72f6c6bbae665daf9aaba6898599355da3cd85bda794d50ada206d4175a978349d8951be4a463221519bad3b1b7b8aca1ee823227b6ad026f0a24151f685aee2e63b86a055ad52b60a798c9aa18ec381173c38750e3d453ec196fde78cb9ac865ec1de9c49a214c93d9cab6264f64a2e7d7f9f9bb3d51ed5b6b9d370e4cf0dd200b61d5452570aaf597518356662e74442b34e123ae8f81ca5c1b1030f0ab34fda9004be33bda1525e914610ceee1ee791255f127de8525471db8e22333b34298b4490d9f6514c8be106dfd10dec53afab7dd63b4d2ef7f03629f39e4093218293e161b7e20dcbdd9e7813198bf0d275d662217cb6a52a2a728c9d152c1a13633515643ea02a1ee4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
