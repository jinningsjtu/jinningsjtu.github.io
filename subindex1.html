<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41bb883052b968d8a7ee4fe835f2625b41028a2514fd39f403e86dab5fe98fd5efaf82148de1339751d5708699b5b993976172414c145ad7863b25c1aaf7eb54379f39ada6dda7e3e9d34a46763ef6966db9f60a1fccf2c665b07d84c0b2c66d1972356aff09932e20f3953c4f375b05e5c2a6f6c41d574825e05cf89154f346ff700eb5c61e63eb91abdaa44a61c8abef9eb12967fa4feead5b3568bde9a8b99cac9cc8755a81404a8a8da087d07e6d636488eac63f75bac4f9b23b27921045180577553739ac5ad40465e358e21288283725e734aeeca097d7469aa941a874d703c1e4fcc8b8f03d1e26ee98dc8d1d061caa24030a0aef88369b449d9f0407d791b4c5729a6a7eba087a3fe3a7b269919b7f3fe13992a87406bfb45b96276f3203718afe35889f4e145fe98c3383b8207d644d0cca8e2e184caeb859e3989e4a23603006e63ac8ed92a36f248df6f95ff56f111155415fa5c503348e6222b1a41002cbe676a4a19d97fbf4069997474521468a5637bfb40dc264503235abaecc26baecfc0e0c8dddb774153cc9ac44fcbb598dd7b7d7c498fdace0266483f809ccd2e3731353451cb9c1ab9e191ceb1a42c4561acce6142c5e228bd51638f76fae2976be0caf865f333cde20654195542c42745d2d990c505325e41d30b215c170872a81d5adb5c4a1c1a96939306f74676f39224275ba876669b6303635cc17cb6770a2b8fee8724b50eaed2c8f7a98fcb282d112db2ca79c424429e6e490ed7ab099eca290b4513b2607f3e3671dc270cb0749e6f479323fd01be0f94a9b37936717f8d86be1a145f3d21aeaaff6bfb182097cc7200db177a6c63a3d79b34bf01e2dd50830fcd32eaaab7f22e30a7f560f724eeb28b15867ceed48db32f1208a1f0964fa3e757381ea2e13153a573ecd388bdfe3ac94a58093aef8657dd417d061e4b8dbc3d2c1e62d54cdf9e453d0647b85d515e6ddb8a6e4095026ede39e398bdc13aff2885b76e3762ecc7205fdf60d7da66e93a085331725ca0adc6e3fc3115f461ea20bf2809344d019ca34aebced52f9b206ca3cab554c8b2a635d2593699e8f000a6a1036b840cdbaec524d2714970c8c81c0df3d5a6af03248b28a5f0a0819cd33eeaba03447d47856e79668f2b18d4435d14e61cef46999140556cf2ed9ad9a6f3a375f694da62bef0e158701be66f1f62e0f3a0b69bc877df0bc84f8b151b50fc84ec8d240c029e19b3a00a01434d2754276d9bcc4236d0acb01a04039c188500f1273cfc7d7c31108555b28b708a17f91b7b6ee59b9746b84685aa4d0aa5226d1c7d187da19f7c4c4730b6e33dee16f1e227732f271c9cbb4f45986152cfd2405a76ccb410aed7fe9cbb15a365b70996bb2f6142d1120709f33dcb74de07efc97e28955b815bfedc16cacb037f881d2698b9caea7fe52c07bc68f900fd6c3f908efac1ccf8f89c1d3e6120f06dbb349590c385ad7885968600e21eb58d364767e647ab88e9ca6da52ab59e60d7e4a3e5ac17bae7c86e366db82a1717122ae032c32532be1b4426d1b02ec343b035af448ec0978b86af0426d2af8a569bba063a5539fd00b11633c359856de1e14f847c5872ae728e680f10cc2829059a01587910446bd58a0044ad3762b1a8182bd56a34c29b4b6519202bc547c12f5e76621c89d88646d9ed7e3ac2cf2695254feee80297183754c835b5070f558bd6e556a6994d7186decc72d8bb0eae8e9930d1e9542b8bcf6e253f662b1c418425b43384902fe362f94bf9cd9408642d8144bdb4fa1504e1944e60f0af66b6dab02e99a40a03dc1f7fe72fc0b6116156dd869d2a52ba18233b033a4970cc742cd49fd6c8e5538a531bf2c37f82c56374b99c4df64888088435d67ebda34e8392ec2b7174061466b44f56108b337f71c7e6d10010ccf70a4c0b35a722af2a04333483a07ba65c84f5aaf33ddbed7d512dddbb6e885bd6419115042ff54c8465fabdd39248d40a41ffc0688b3211c908fbed8f8cd996f08a1fcc29701baa08ac9e4174d9bead5553883acb7c3c0bb7e19d5428fa74de5bbbf6395d76a459ae57a271a9ee288e9e06fcab4b996d0720ab281edee315b5438aa1a558389f30152ffed5d85229e9a6f4d1795f145a841e781a57200cc5ab72b20c6766205e5ed41adb44d5386586a07bc23d8c3497161e06ecaa28540d16ba500d30c83a75bebe6a622dfecf1a90c93781abced966924eddffad3e0fda9d3715612f16d48459876460bc445a697a9e7e4915156d1ae0741534daa4ef343382d1bd75ab5af07c22e54f119c6dd623627e9e50d58fe87883eb377dea15e27a68aef9f0a643d91a97d42570300ef886cb39e06414a9cbe221ebf1ce7c3e825b9492079c8857524e84149bf7ffce3074400f55d56aad8e398e4f59ad6f205caae96c08e8c6b1cc1d3a943f50b183ff57b1a1956cb6bdf737a3c77e9dbadb6b6b5df88afcf7dc29d312877851f939c335eb2cfeb16a9d7e41231e2fe93217b505d522486dab6188f8c62b5e35ef5f3882e4aae3ec7e0ea5a8544a46496a8ab4ac3b47a5b62b0746636f7d93eff7b8ad027f88cbb5959be1629852857e43645cebe1a3b23659af21e9dfc4278c8cc8b6b7ed860ca209e56c1b9be0cb06aedeed5e92737a134a32dd9861690e5e05a6a43e09ddd03fa2b2dc076fc4414a0f653182c946666ff75b4fb29eb455a44cfac4ec5e9acfb7810141943c19b271c17d38d9c9f5fd419330c7687a97a0655d42ac57c146d8e616d2dff0a32ce5bedf6351f36d5f73b08c86a6462a8e09ffface9eefa7d635eb55ddd10ca3ac3239376be1f0bba8431c34bd2a3d636d9f94d5ac35b9f80938553e1b3b66aa90f66396ffd08717b7a727fe2da6e73e80091982f3ec1e2df7d6d3a805e5c4989fbac638e872e72e666fa3cbb19c998608bc8fa9580b1d98b01f68cc968a851959c378ef732f1f883d439935f0b8732e97eb6ff62d0fbf1452ea7988db4d4c50fcd9877c765b1a66988f85843a1647656338e76e89d867d1bd7d6b2235ef3bcfd9b4e0033ee547cb42e003174cfb5da6158fae3c269644287a299c0bec8c2addf0da1d430027fdaee83a9628a25518f3e202ae076206fcbd784193d9ef49dbd5b3e32beb34467bf7014b7451aa058ebf1bc61a0e6b16ee610286b279496fe83cdcc76821b19357bb56af24642a1a1aff0986617bb67a5226446690204150aebbabc63ad8ecd3612c2c0d99a05475d7b43e6a12104d94fa65dcba5c120cab7b4f3ec12d45ca70e88a0bed7d7f786dc220fed49cd617b8aba742d9f3efc29bdd41e49b217c8ad18467cd71de0ccfe8dd8c3661897fc7a7fe4ab10677e4a474fa046e945cdfd4250501a26e71192be8947762168f5c893216ee4b60d89515dc324ffdfa847c99c80d33ccaf2fd161d923b30c0d566e9faaef0edeec36a946f89c56a8162383eed1b266b5532e602f5637427469318d835dd37d80ff523e1add6aae79ec31657858e869b20ae11ac639ab1b720173b98bad3b009c17ea0f2ca9d451c65ba6921f332bb104487df8c820aedb34a3e716b1e7023f5d0922825e984c9aca5538ba1058c9d869b79f12471e1af7df62db1cefd0e493cd5e17c6981743d3e74ff84b27287c4a768a0493c7c88e3d765322390bdb45d2b37e6d5d3a830500fc4ce3de8e2a7c20515da5c49cc00fed4bb8679aef8432d953bbef7b01871b658c82529cd90a03111513aebf44d43dc99b36802009575c8635811866a39b0d0e7d88beae9218b0bfc1d103415e3a84681741e3c0ea0591bf87015c845c38ef63305839f74942a7f9ac90a326c7b0f5597447485473e58d631f97e12a36a5170b12f8ca35650ecb7011665719864a28af4f909781ff9edd5ed2ca41bd4e08e93ebfe4920aa4144ea9c3ea24625160dfd027186fc9ad8480ca837684e94758ba089a9dd9896dd34e03eeb78db03724565ef83b217365ad71236d3d04f8fc0788e519bb20c2c431ba88492dcee4bdb5ba02d4ff349e4d4de2a55626c7b9af2e2378a64a151a960bd82609068390e3e0e3637281f246c06fc7d361aef22602c4c6f9592cc0ce120da6807fbaaf8ce6657dcd8f9ef4ac4948729d844d30acd16ce56d52614684afa2588a29c05be3fab61d76f712da1d45de585e6ad2992351b53ccf3f0177704eaa3e317d1cf809f5668a7662d1b458a0315c8f80dea3141fc5aabc635174915f77193e9717c8bc016d4f80f0135e3b776a12f5506df55ab4e4f02d8660cc86759588e33452adaa8f266cdbaa519378a1356edd4abf9479128ed119542f19b6e9ef530b484f82543f1bfbee178534a6d76fe6ba6940a5dda87802807f6140126bcf8e38a4daa3f54c38cba7eb9c94024006a990df3848f82f3ad1903cf030a40110cadf2f9b31c80c9d0dca57e7e7ceab95aa6b8c867604827bc401e5b6ae5d7a5c77d68efaf320036b8b7785d56636ae4b5761f82fc7417ac44972bc8f91d3c3ef659856a6418df7659c5f245e61e5db019490b692b18345d4be0e13dddebee589fa932c6da3806eff370f6aa4e1f4be7ae8195dff78ae07a3efc082683467bc48114eb0ee992478c99ab70c1c718cb26ad9c4b4ba4717d7eadb39a437ac4e599e34a11b651fecb0c0ffa2ffe6064ebca40d85a4e23f057c78a8de5c52768ebbbfa9629c95441fc8501600d3865b110a04306289a279cb44498f55bf6d0aea71dffed2f7bcb9fa03371a26dcbf10125596540262323dffa8322794f6d9def4eb1aa585eaabc656f3db2752d8de49c66d93799bc296ac976ee19603ee5b8c70bdf6a77fb89f33af114372d8cb7660206b669f972776d63c381d8d8274464e4560b7e9d6330d01cebc23c532860e387c8d26fa3789949482dfdcab51bd9443af528ffc6cea4e98fae62c01d1d849d1c9533f7d88898b6b87757bbdeb961b24e34f12e21c949baced5b3fdaf104abb7d2b91b384e9d34dd42aa54380386939716a591c520b5ce79a78172c3f4cda9b5f1639c93c1cec8b0994c7815e4a94a82cb47f4ee36287c26624d014620b4cd6490bb9e0f2594013f3a9eede92926b081545caf8ad09de58f930e73765a7769c80f3f5e8e0acbde0be4c78e1bce312970ff6a63730b635e62c525821dff1d770055ebec7cd5d6f5729cc7bf7f0fcf573879d3a2b6c3cd566d4dd05e5183b2a22ad82b6643b0b78a32d5808d9fa62d0b5c8f74b835acc8e3b00399bee7c61deceb090a96612a23dc869a43e32e39dccfd8f24929aa7cfb25f4c297b9fbf90867144ffe7317ae73fb6fa356a10250eee17e0e0102fc0f9bd61513c85c6fede2340c67eb64520f97c33d06e7f48cf2267f1e70e4e56a0d1ee1178e8e7fbba808bda54947186ff9e88204fd941aecf54642d3f3e82516d9fea394aa18c347788494ce56bd75cfb2625ef2f864a261d3eb9567e6031827a934f5fea7fe1355d3fd1908c195c9f9f01afa4873feb7602328647aabe771524b75bda084170b3f17c9ca5302a2d8d65578d889957c09dd77cc4284765dc0bd300e1672bed731f136291c38da02494c1cd9b69ed07be4c1e1bacd075f45f902e759b599a1e9159840c23f73f6e8c7fc73e44d29a49661653f1836d06080f31e221705caee89d1a61cb7b7cf1a48f685937c275fd255c4a4796e34aecd5b58e59a438a63d1bc317236fb412e3a10e94db9d35d720d4209c40ccb38efdf3b09aa30038cf7628d8a813744f2a80c66862e205e5325e70f5eb33026a3297279f5a7eeb1c559cf3025246d61fd5c64000521bc7e7e3207fa9cf23357e81dc05f3b2ddadfdc452ffa581c34ea3a87f2cb4309b5426078cf0c888eb7a81bc9fb599fa7a440d7052489f6ba1301d1f9bce357940d8005564410fc69efa7c495673d3cd2686ef9076cb9c6b465bd4e50438c51b3e3b8fedfb58b7a00c70c73588ada52fc49f14d7090e1e908d89cecba03aa8be04b31bf6530a711dd797cff7f9154db82b77e0b7ba66685bddec7f647038891ca9acf2a15aac0191fc5734620b42bafe0a7e06a3682cd412ce1a774da665077a36c1a3081d06abf49bc0dd1a4454988fe678d37c4c9e4600c6f8859ee958687f31debe7d1e0c3aee064c7d15d016db53bb785ea82d98ba9cd7a85f804bdfd3ababa7fbf35ff5801e3c59ac2c762c515daf4fe15e5bf4f60291a1f7b3b1096596f5042bcce6a9a4a740124c250e2cd33d0584a6707cd6bfa387230a13d88979e820642cd2592597f885e2c1a6500b5e694dd2dee4e47d7baa8dee45c566a8fa5498d2e642662de840764cb0ff42a6eb967367f8d75c64251a337ad95250c66eed9fb9bf940526098787cec2e4bc7218ff6ab33c2e5e08936247c8d61c15dd621789bd4bf6ad1a726bd5dc478100813cf1dbe043f45ae820cd2fddf1c9bf37743cc5f7020e431adc9e3387235e7ffc5761d5bfc6fb89e2120fc45a023a91a53c68c30e0d78be539c591b7fc8101bc4e5755569c1043b89f4c0ca453e30daea399dae78949614a234153e4b2053797fdd2bd2da674f08c998896596bdb0281dcb14abd9b13ba3fa9650b7da097fb140c43f72805991e3cd979039460cba8b727a9ff7e1262514ad45b6fe5b87607f4b3874b9836d01e8af4134ca425ace129deeac5aac5b0e1af0c298a5d0c02ea511511f780ca257d107e73a837c8845ca66b5133ecfc336e5e6c4a0c9eaaac1d7c25eea44398b8b18c95a15b78ab356b98919b0b878e8f1418cc094425b94a481abcd50272071d301d8f01a7f2887137a533677b9bc8b47b3561e886e3edfa15395d27bd4785b4611c0a8f943c377c8dcc0ac06ab3c16e0c84868177cd91b828a33d3dc49066ead0402e6d97225bcc89c5f0f51f3eadc4da47ca451661dc6f11f9c164fe98e0a675460d90ee9a559b4923366780c8da512edb5f22efef604404ed3404be6f390d3fc4b9620c7b65cbd932add4786979b8e1e06031e8eaac765713c8d36950a276483f0db75e25180def0467568f646015649ca243aa5c363123289fd6462bfaef915eaf2c329190f5a58fa8fcf9b39f456d8bc7e91dbcf907138da106ca0e6726c2cff24a4f6c9d376fa2ffb28c037983427e11103b852f14c8e77267198d9a1ded002d71c9bc0c45e7371cf3a8f5096f0ea2a1d48a24c3d8f16390c425e9b6be113f2589f54b7cce69576139b363050c71fc9fb22b8a3b706a752d83eaffd9d1c4bac47c2eb8823f5a53d8e5fc20df96833f2ce98d8ab856172c8c59bfb74e0aba09f0e33ce4bfbd714fb56e92ed06d2c34d86a25c90ff0306578acac4438a70582088fb6d8d0eda9be08c5c713093d21c2de286dda780d824dbb8b7ba8a4c85f25d78319a4bac9fbafda96487e0a13b2a749670c6986098eb8898541bb0f0597a316181d2d94e7eb4923d0bf3eb85f0f984492eedc03f3e11121d036bb09d1c6361214e5e564e2a0d294063c7f1d197f689a9b351b07023b667304e46552b67a946f8703759b326fa1c0b7dec29f78fc634204fda1a5e735db4541bb4fe1f71a08193f41da4388334ba0e1e10032f440c5cd04986779768f6fc883bcf649f462f025946705752399a611ce6278fac9a86eac140aa89322b7364aece387c77ee8c330accea85bc9b5d0ab529b8095ac8028d702ff960d72a1ca208600906c0d429e8c680bacef4eb073c16abc5e9316d1a6206f56dc91de05f9bfc7614cc16a313ef6c98a34cac52ffca6e5596d329ba68971a6f74675ef4733bebf2a240dadc979db4b268f59b317e85cbfe31d5fa4c4831a320d0d67849ccc35b65c4bb36a3c3eed5b5115c623001116618cf0b9ad55a0e2b0f36e8f89895c8b7b86265b8c2d4af3ced7f5af202077abebed23376f3987ff4936a5f640d81774d9d072cf950be6dee9057ccca72e7cdb9b18e308eae32067d6b1601b6f2b79f808280e2ab9e93662313d4eced1989114b2417ec08e52136b82af48c41f1b6619156eed30c8177e7ee7a37df28bd43bfa44aeb2eb902a843b9c647e37a1d6a28412c6b10a838728afb6d5b1c40750a8aaa3918b01e40f0bf6358a0cbbd1070cb1fbd948c251c5860fe749c305b3ddba3dbf510791d344d397751499a59f3403c1ff90a0a48e18fb4540e15637344114ea97a68ee3944560ed54a6b21d90c80d0f8995a3d5092054f1ac629e582f44453145ca97579a62c26dce46a3854b3395d432eef1da966a4e4558c489f5b8039359753da1f54b227519a4cda531b803fe293a03081b89765478dc12d2b9ea8c3b56c85401e1df227f5e8e09bcfc7b71b5e8f1f15a28736f2e0dff141a0be5ecf5942df7a7f6ef7b80a4c308892b156b715b3026ef65683a72b5649d7f8e4c6dd2038fbfec9a1fb6b1482c5b1134573e812e907d3a530460c53608660c7bde5a71024d9d59ee0570a42dda8821b0501243e51c22978c2a7ffdc0aab30cec85a20676e2cc08eb72942d307c5b86bc0910d387e22ac01641ca8d845dde72ce64976ef75dd969e15fde647e1790e5db75f8ab34df92a9db12e6956c9d112341e79b9d0792f383742eef792e3a15383c35cd64a21ed2ed9fcf8a9f14a3370c1348df6e156daff23fc30e0e73869f4850a604d643d544cf21c749598e4a8b6e6c4b7227cc6fd9e8e722600f6d7dbe50fbc443902ebebad565a6a2a7c7dfe85e618fa163a0b6abd9e94e8fe9ed2325604234f9ee50d802f201c1aa37704993272c31b75e42ad5c6d9c6e234ef04da54206c51764ef631eafe034cc3e5de52470441f523ba0aead566587e406a85c0dd9fd32316c9e6009612c707d8552f99be70835d0f5933e4b9fc566629f31db88da529d51ab7cd27747ca6a9d744163743da112d3e05c907a880dcd5955287076c7b219f60798f60247aae35cd39f3a8e9538cdd69ab7a598c137a7aca50e08a01274b451270718300c80df7e0f578a2c3de4f6179a40c082f0ec190e818851e1b0dc071076db477b108574b80f84951f76a72d035e3487d865eaa1bb093d47d4b4f87d962cb8ee7b37483969039b6a42f44fbe9d2db580780820ec1b3a964eafafd6af3c0888a4811691c123596e8f0e0be13a8cfd7252180d91a639cb35db400c6dad3792c16037b33bc621f6ec3d5801b1ebd0edba17b0d7c065b68ea562776fbb41bb43ccf84cbf89ad6b16d4c68810d46bcbc679f0f27a15016f4e6c60f8d5e7ff2ce2d0f27c97154d168bfcb4265adb706bb3a92ac8cd52dbd302efe1be96a52569219d10a5c7daff25b503cf887710c9f0052447a0bfa305abd834f9a411ab7f27d61985efe62d3dec32e810c90b4138a36417bed9fe973d10d0453b856411df9d050de04ee1015f4c668ace9e2654d806e1195101c4f83c826942ed8771121e191e856da0a8c9c634a2c00df00c87ad3cc5bedc297d1bf199c852bb7919d0c888b0b04e129a2cc8b44ace62a812f5df6ce7fdf443461012b6b7659964005dac2ca7b495c895eb097d8e17797224b078b95ac1d60ae2651417df591f5a0c6bb2accfd0f852cbc78297366dd91d3bcb0408c2cb5a7f047601e033a28e86e2b053b70a98fd71d5c98b7f4c4f4da22ba6db9c2db0654010e931c72fb501ea16a1d219f84e3a48d43b3b2a407412559926a6a672fb0e1f67becb47b4149bfc97243f859d7151d426179f85f94eed18e1db41cc654976f534af5438fa3835c771d5bd331f9bccbcc8e639733f4bec7b79e892fb93111c9c7f0f309f9d036d0042363c40fddf393a4d8ac7acb9ebcbe46bf3e3b58bd4c6ab50fbda18811019846e6e32c9dff25f9d7dc6ee734ee8f92b7c987ef12c4f5c28c7a2155d21521608e58181df38eedf304c342745b6a4e2e4de7cd3b524aa605b93d36cb608544b3bbcd4bbd1cc7477063e1dddbf58ee9a16162e388dbcbf631b6ca8a8213f0191b7334475a083229e507ecec1187dd750b4dbff26450b30bea8ae104cbb30cf5d96ddfe17237be5675972eb4ae55950e66a40e29d51bd55f4ad245081f0bd8d15ffd605eede97568ffaa0374e5ac02c1afdeeeaccd7e31e20699f5217d7bfe04b3c3db01351502ec6118e03ac1f741504653b73ee311d0082066fe5adaf8fe9f7258c2c2eefaaeb2128a28f4e2cd7425db7a291adceaee4b2e4e66178193a1a0ef2397b091d7f26a6650a3403be00910c3471622fc44dcc7d93afbb7910cf2a26336055add117053336315628afb325b26f1f9ecb913e709f3004f03147a8022f0265eb75d13ee48bcc31755e839e92c77f56ac79fbb3ecfb89d15e201044b5111f0f8ff779dcce2c013ed756e7c37ab5f2efb3c04ba25ddfb8beb8fdf76a04398683c80086a2fe64504a9fac8d87679682c7e8f0d898db4beb9a7e70145234bdc8a77b8977b9de46fca3bbf7c2489fbad3172e7069f2f79733599b9f34ef23156ca5608a366cbbedca8f52515796f185f31987acecd94c03fb03795f5cde54db703432fc8c1b0266c92e19b409ef0cd68033fe2872855149b9a406730606eec2e7cd7dca615f9927a0e598b8fb68b7a35e66f1dad05b73ce76d9ef7c15dad41f82b5cc4ee5a536392d82e7820b280cc5d2337f51d5ee02eb3a0b95eb181a7e299c5f5e6447b028d53c39b5403442723eea734ba243ac8a34575fabc6e64a8c5c7e1f36873fd62dc64d28d7550c5fc5ca76395f102cdcc442787691fc77d25973716dae5ba37fa993db1642f712f42b8a8fe0a79aa0f43d3edc8c770d0ca4d9e3129bd97e51252802015699c0460f22803bd778ea1cca4738ecb7b78e4da9ebf38e8d6239e0e0878daff57cd6090929a06a16f7410758762e6467cfba768f0e42fe7b36edb1f1e92b0450785b1a95aaff67499f5c73211eb707da2338dc065873a63cbb9e145b7cec401443c0664600e4a359b6d9797c1c0908762c8ab0a6a2fc946602d59102fa981e8781d7f302e25a1415821af706463307b8c855c5695a59b9fcaeff0f7badbb2034529d933d16449c8dc876f0d8299b3ca6d907bb47a49231de9be7de9080e6a9070e5034a348cae3f921a7ed31812443f54e2421ec29a4decfeeba33142f7006db2a31cc71b7a7a8667083747001bdd5237e3e084a90685a09124420023fe0e6df51c196677db5df96df3ad310eb7288acf3868888f1aaf33d91e7c496d7a486a219612c337e0af45e87f4d3b45b39a2b71877666b832239b8fe670e085258ad5ce686dce59293bcf8f3d3e8f5b3d94061ffdd1ccaea74c05660aecb5241a2ec5447177b0ea090fa9a0c7007da192f8a6590d3dda994293e74a566941ef069b08838c059318f995c6551ca31b9b196af0267bcaac0fc51ff0d8452f5875ed9b0f9cd22bbda42ba7056480de24fea0e34bf12b29c1527ffbbf5bf7274f0c1bf4a6aea8810dedaf07d325cda84e8913847b6d35765fe9379f23dbcf64b9c6e99c640730ce8c37148a264eaea330ff463591968a2bcf895bb85041d00c9d1fe2b6e28a245c23de14e1d29a0430b2dab113cae5bfee5ecbd55623365c7d4e9edd0f5e1cc33e354c4b8c3593e662379304f19d63a4aebaa6281c8eea7f156f88c3d7c6a699fbb93398f4707561b27a2555bea5d7107510a6441618eefb30e1d134d75fc8c0c3ce27cc445a65815f8e545fdb238aa37edcb44ab25ca3a11597acda991a05d46baebad716dbad198841eeca3c6d049701b1f56d699f21103b78b32d316cd0ba16debdf6eeab262a50b708b23e6c4a3da0b0cbef3770a2a957e05c35d84791f1d7a37b5e9c0ccb24d1327f2d73868ab8b6163e5bca7485290a30fe082db26c5f5c268b0ccbf67c533802abf405d24eec23501fd19aa30b58cb3b410eff524fcf829581a7d11d064783048675e42cfd375d34b4b9af94c7e9aef500906e18ca01c042e53bf7cb647b1650119832b1d7af553bb5a8c2ef0240196c8796560176ecbe05ee5f84421fa9b393902608ceec74d07ac75aff0f71198d02f39754fe397a86cf0925f6304f7a50cfd67c2b1b6469679994c12c0938ac29eca9615d9649b33e46d0f1213d76e68a16abdef98dd2dc142b9ee4c52c4e64273c73e84d23d82927cfd3fd282dcdb3d58bac60636cae20ed83ca447f0a05fa15d54afb3100624a913a76a83ee2adb3a58b8d4089b3a5058c7d0713a88eb8d6ac570050637dad16faa2eda5d8610fe25a635e07b8b2993f4a548f05226a3d9285b2026318a80e92fba078fcc8c2b965e35f7867631671f25f753a0f6a86c90b7b49cb0330052cd04cc55e8bd3e82ccb27599f35f2ebc47fc151c0bcc2185a5ae8a62cf5e8dbf7418ae64bb215d0458f23122cf2888a914ea1eca3864f15828ba674c86c7aa9b360d70d8e460f292fde9cb79175af1cf4d30a1d916ee5c6bbe5afbfb22db62a5968ef54efcf814cc4abeb1c65abd74d9bdfb96f3374c67cafe73696e042c298f0b1b9f7cdc15da580beacc98426b05bded07d1644253d1e6ec5a06639279f9e5ef2d0f492a1599bf076d1b3a07716133cb8ea522a99a25fa4109c8b50e51faca92e2d1a89647b8244b18ce07aa1cef5d5aae3e546e713aa3a3f19e33824fd31c18e85609506fc1d95dfdc4572c7c21bb66aaa912457be0868c04049f51a95007b28f9e43b9cbde1da47ef05ff6ed67b92ab4df19984985f7488d0fd2b5eca5d901de22a34ffd3ccd7fe7de9d60d1b9d807308296d4664843ba9c9f1ec58bd494d2a6e0644ad38699fd211d31fc9c0396901f27f7fe887d7b00f99646dd204be921c7acf2ccb4526bda160a6e1b404754effcd7213c366c7ccfce281daf82575d43738dda6e28abc2a724cab07e274b6acf2e30107587940d277d67014ff756c4611458a6629c288a5ac166167d9eedac97b33d9b8e9b042a33183bdef275d91ba3a3308fa05e69fbfb3b6670cd653adb4838e14fc0713f3eddd7e601eb6e9488507f7fa0a57fdea688bdf5f9258014663614476cbad0c89f5fff13a365bb6d5ec41568a36bff15ba51901487ae39352d2fc58eb4a84ec8d7d0a5c1bfafe285b918c22ca05831bdb861ae2af0b46086eb019f772482145250a4caa26e061def1a267229d91332b448fd467d6ef074d283361fb93d4ca8e0e127f68927576b636d07cbdf1ba9d18b60da92fdcb49680da9e6ef366ba0c318d9f5cc730c75330976f6fb169a3a2e69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
