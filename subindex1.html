<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f3dac2a219b4ea39b01145f621ff11aec4ae7a332d8acfee1fdd78121353d037540e83c566af6ed42e9ebc45db4a78c9718eee379e93b47232325ac128fc8a7dc39126dbc6080bdd0af43a293a0e473906f241c3d75ff7b5f233e4b01161c59967e4e04d42deacaac62b50c4119dee1d0950ab913d5767a84dc25acbf6468f0a7f28d344c63a2dce7b8269f9aedb43119d01a0b021b392c2ab13b1a99fa2af206c7906c37497ff601cd72899b2814f398f48883b0cd02f19a892ba16b31771cb6f2dd06768d0d28ea23c2187fd0b35e4cb155ef4ddcfb584d74a531ac4ca1eb41e3d8f245abe26937b795b9f913e02a3981c9b86e6e4cd26726ac0875067708fa94ab4bf2b78e95cc9fdd307b122d8cbcb830aaa804c3e919da051ecba44dab6e7784eeb5caf91e08fe66e710fea7e4b442cf96c412868c7b8c373e88ddd73059874a9ae426970e6868abff9a1ac20b592fe164c1f753738e8754247da3502d3ccf91f2acffdc0c6d759c2bbe4d7123be3d2bb6b3375c5ae3cef8e1b02b512fc1c5f08e22627dc82ef387a1507885d4c433d63f7a4b8367453c27200553dc8936e49f467e367e4a3fb89fa5ff1717bd84512ba7e7ac2f951714be7ae57bb3c1bfac6aa138f9b20824ce3b70cc8aec737a57af1a3fdee3a96ede5abfb93873a7fcebc9abac54c66cfe538aeb2789ee640db10f404fd3592348897e2edeb5cc137ea564fec0e4ab6af1c8ed3769cfb4de06455eaa50f74e487045bb2ae9c8cbdd601f97413f2e1278f5bd7381c8ddbd012807fc71af474789a5f77710aaeea9db4d86d1e9ad311344321d38a1b5a1ea88d03743851b1c03a542a59c196234dccb0cca36032cb7bf64354f6821d0f3aea138ef5e6884e5955ef080e447c2ad368cd3aa06defa6a9c891a719ec0d81b90875026cff0014249d7228dbe7e37ea1552b5af0a8e57c80e1966bf20f76c8eee0a586fa0d7287b121cbce16eacd03d7a67fa401ff32a07d7ea9fbb26e96ff0071a863e18230f428ac42ad783184241ca4d06265bd5e203fdfcda04feac9396fbc4c7ffbdc5adb4e524f009b903f2c876ee742099024758800a27750abe57226d1b8ca83c73b15e6ebf4d692a96065a4a7fcc027746218097cddde00427094342690b6915468935a2123f3e0eba24d01c15da50e862831a41f3a2fda723cd788b96c7b1ec9f5057664125e319cba745b36b9bc6a421822140118021fcfc2d8c0996b0c18ae0795a09a0d810fd1b538d91d8c0c57bd4401b6c3f82587515638932b035ae7f2059126a0aa9e4f21ff88f5daeae357c34044ca7d562a6b7502ae711d622570eddc2ea76bcc46f8593ffe26731f885ec7acfbea98ae3ae898c40d2be939c8d22220605c1d17321060cf3a75694c25c362556c8a5bfd12524555d715eae53ae62ed75941ee1dcdc9e441fa572a31754bf6ebdae84251cac54f38258df2b548b2ab3b6ef5af09258679009cb0c6578c48bbbbc70af2b984558be79599929d67d2a3051ea55a2112102c3ed7ec7b1e4198bacded707328dd5d1bd38cfce6cc02509887708e553784458bdc5a68c4b9ba36f68cfe155338841371453c57a64d581efa92c0ee3b1fe1c6608fa979b1dfd2d77265f45126738e82955720e11e5a4d5cd1cd86c82449394d0b88d7ad647380f013e29c9f4d8978850eb6321a03f8d3e9a7f18e72ee9dc6110fdbb6e58baa41a4d1fd31455deedf76e4e5083ea38e53ebd364864209aa0c9f3b00132ca579940bc578bed9e47cda166677335b24f04fdf609a9e059124110e6be5d01064b0a62541fb997937a120746e796cafe1237b4b0d0992e71d2fdf56b213bc5c3b4ff9f61b02bfcf2306e207d144888328490896e2056fa959c7a621ee6cf90f72d85ed8af2fc049681b4ee5cf27e80bcc2ac0d43d0f98a3077df37ba657e022afe8bff373af53d3aedf55835f3e9207fb58e7e39eb73214a3c76e9db18436bbf5be17a2ffa39bb6a841264c8538dc4f4985448e7e57edd1a858c707875c80f7386470c2f1938cb6f562946b2865347b72556f5f699868b6d4ae3e6b84c200858d8d6e5b215a1da8924099eeae1374aef6c8cf22603c027ae4c4825e5e3d65810a5263a266321cdde96a420f38c3da7bb3ab357d07e987bb891374e604eae2149dc370e256f88b242b05ace0a6cfcaebea26dbea76168f2b8e2daf596677b6fce8db62e9428d897ffc28ff98a51cf50c3324c592a771cf35cb450cf0908d699322aab2b27fb55d5b8e396f3172bc7cd9907083a9f1633ef2d478b559a030474c8a42befc0de0ca6e3bf0df54c4f571cc3f54581654a0d3d93014d0389314ab4b3ccfc971f0133f7145be3b0296d0e8361f72730b2dd584b42c33b231242ee4bd80466eb301f274aaf3069719d2df2f3bb4bb848e729109f4d96af139a8494138bdaff9ab0a736241a2f8c2010f2e52becb24a654df97f1ef4f5d79801e0f070afece1a1e917f10e99a7f76d8eaab37d157255a9b8290bd14144a456f3aee6d2d5bd7fc0575b2bfa14dff9a348ed673325cac4e1193c859970ff438e610e66bb4003c5ef85f1bdaf3c9b5962c61bedb6ef6bd7d7bf1499d1a31c83551035efb38d074bf463ef3de1a187f97be4ad6d8fc5d780c0a51fa0ffb2de95f93b64d53e3f4c379c62b5f31e63a34aa23b6e8a157e1a5cd228b8bb650d3970606cfe7d18a3027224d5ceb1a40e745538ca93582a024e0fbb8ddd4d1a1d5514bfc163f99eb40fbfc0425536d0ea142d9d0dc7b9aefa0ed03646898b4b1f2ce74598c6cac4552f9b83c18c2d7b8c94d60797bb89083b74c6f94c274324260b636b05bfcde4a2cc0f9190d23d38653dc4be01fef36819d7f296f42709dc30d63bd2749b17ee22b8e320f9df9dd71d03bce36dffcf211b369a71d51f6fb7fd309a7d8470e4d6eccaaa568d2cbbbc57479515cb33a113bec49a7cca64a094d4a7a6c2033344e8ba2474d828917bc0e9185a222bf5b08bc8ec4acbf8831023f506c8fc6fa35f9825932e5146d459722fcd88f2a3866146ede0467db3809e796d90aaf4f1190d049729bf07ac56bc0383f82689180bdac6b51cd0a2bf8fbe563f2a275e93823ed1d1381ecf1f509f9c015653065ef1017036995e9f124e1e0343154aa2dfdf5eb41b2a542c2e5c64ad35876e58f2c4d18f2dbb31984e1c48ce0eebba3e94954faa54ac2b5c394767c9f62ad05b2075a437ecba04cfa294dfbbe3254e0000794240d919a2f53c7036505f261b5428ac1520ab43e98e347eec3f9ef4d33af9ff4af3593b88423c5b41975c8f0b29498a352a0b63cb2e4656997f067b4f39a92beb0059cdbfc846660dff4c2bb168c79e1c1991f56a2317fe3c2c7ab94fa156d1aafcb72a0fdab96ffa499e57687512acd5ef5e91af1d236185c1153c4f1ae927dbab8472a7553d2294f91d54e7504c09649ce7c906d0b0dd7c9d5c8123aa1c39b55d66c94049feb4bbe581ed217f7a2c6e4806181ae2d81c07f9b857fbffcf86999995ba7f32483b9d1583c684f8d242c8d096804909ededf974759afdd365491410c014b69b725bd4e423f1a93e6763bd856ae475a9293c724905828a4b267bb672998508a138cd70c1d427344a930b079ee42d5507a9959ff6796317955df10f0c9c38dc6f91ecebc5a42185f3cd35f5c72db396e682388b4d31508e8e1343be64ce879b360382351aac8937e8881f2fc12c2ac983920977bf83f60a37a9a362c52399f6cf9daf51ab60145bbcae166a41473ca1e597cbcb5edd9ad0b8de0ae765197a7a2355bf89aae33e276473f9c2de3df638bac0c561d2c17ed1d478b6330e73e1992da1232b3087049c4e1ac60734898f2814b7d0c47f3dbb37166d5cba4541b6b08336a7fd2961b39bcc8be544816cf13d3daedb48bd48937f484f45975d811682842fbb15a4319c3eafd08742afea0699e5b73ca164a9efc6492ce5dab7471517e46fbae367919e94e64b1512771e739ae26ecb3792e6a3b5d529e553b90f12beb90e98b4886af3ed84bcc66ab8b4d9bb4ecf463d403ea00b4aeee38ae120746e04687ca687e4cf3fd757d9592777c65732890595bf5af5164bdb93e2becd1d5c306aa6b59d47b828a1964665f00d3b333fc0ea402ad0c5a778f5da2b3a94f47006f373bc57b4e23089a2bf0c3733db9d274af7c0a8316295a9df84af8828d89126ce9d8d32a8d9fcef9217be58e33e0d7f562ac3414f83c86dab294ce2743db61c5facb01849433999a6bdab66a122de3218efc4677962bc7a5a6d0762235628a8f5691138ddaa7a4b2e5a78be68ebcaa37603b0527271595036d8b941625a9779282c7c399b9db95946405ff6d86b464e346511431c77f2bafe7db58bf40e5d4596b084f456b9a5ad10cc14c4fc278241201cfcb77a7c2c85963239c32c0f417e8d7aea27d66466ba373db8e7d9d00280355766bfe0af7a29be5cca2e613c14e972c46a2499146f35b822eeaebfa6c043f151e61d8fe6f68788a4aa47bf22b78285affadee175971bfff038d56dc0eed054fb0c1d718b42f5d0b539dc3417c05e3b23636de38d4124dcf67c11f337d7162fe0c13988b56a663d2730e70526a76b8dee659aed6d28289885ab52a0f1f8ecabd32ff6c9107e43c7896357c28ec33cd139b822d83622b805177d6420ae7f9aaeee6b00700853fbb6ba602256696a8aa00294043b37948c58faeedf63d132966319f15fca02e12698a4de4828585dee4754eecabf3d22db5ee3b3b1cf58ef25f3de9f27895b368c6f17fe2b1242ac1df1b4adf2f33da2a4fd48b56f50ea726807f7a65b1b1786aa891b149da3fc5f7fafa57aada52677b8c2fd243ba442549239870db6a7e6593e7fefa6ce87cd64eb65bec60823f69c178c4789ed2dbb4201d3d4839ecec38b6f80749a42acb32e04c7375d7abb7d3b0062500be58a1a738667ffc15227522ec01b00099d37a9c7b826a62e41b05bfc4e37508f715767a187dfba7722ccf6dcd5ad658e4397b9c1087135b39c3cebb0f6d443dbadcdfc11b46876e4d12334c891780749dec6b035c04998b7a5b101c8a7bb8b60bb133d5b61a0ad8425ffcfd956479aae32d7c2a0e963bcbe30e741e3cf6ba0992023eaca27bd0ccc6162fe5d3c964063e920ce7095101f2cd938d14f861b86164a129564a67e316f294583678872d9b9446746c5c1481fe8cb143974611f52b094ee7987530d7c38106a472b838d736753cdfcce48968d2458ac4afa43bf09ca14f55339b733728c8b3fb91902ecfdbb9faf6f2aa78279e8106b2085f9cc029b3f266579b97ec395f2bb55b5a5ed2cf2eff405364100bb89f260a9519e9f22d4eeaad65676521a1b61081e36765a3132f1122a4aa8b815e8491d3ae6f88fc29e1f1af32d67409288511008f647727b7160b29c410168b76f477d77b5ed2f7836b25aca71688972c511a42fc3916b5bf7730ceb99f6de558d7daa9d7f17347419338985a60b6b8a24ed065518200f91870f9f2d4c70f05f9d309bfa46a4690150e27c106d489bff341eab4f926777cf5bd02d38f3b0a6cb7311eb5238ad1b4e4dc02c1041f327991dbc8c6fb9f95293ed0ec905d80eb3a6c4a2461d330e257529c16bf3749b2eb6a143207039f150cef8f596ba6c5cd0cec626c02ccc2571e4ee6a9605ed4de682597dcb7adcc7587281b360c6b51e9575b86391338426c3ff47fdc47e261c0fce55f5a5a78906d2c210de476a266a43ae7c52e7eb93971d2b109329061e001eac6036c76ae5fff54dc24fe67339c7a5c44e16662d68849257888b300149b6efd525c7dbe74bfe1d85de74fccd9cbfe8b9e6937337d0ed0bed659ef52e1e6a2c8c49cbc55386b25c92fb2d27be54398b2aab371c6078105f0b46f39f3215cc04b4095e1399ec1e78e7dac92184c80612b486653a97ad4e6bd6b8a0636ad674c4deb6de71fabf3296e89f4f6ac236867e8e34b389e47393775fc3872286e3ef6ea7c2e5f989e447dbed52a5e0313b4c135140ce3a47fbe08ca8a4578f7dedaf22fd3109a7cffff09008d56da7bbde7e570b563d86c7b979cc7fd9c3a4b7b24baffb883c31da46dd98300948801488a2a710661cbdbfad46454b69c567e157a3c6d46d6abcc739e6d6749ed1a6e423aaee5218ed1affcbb8ef65c2b5eba6c3189a67868af131c6dae7bf25c9d0680a9aa1138188d185bc9f9e1b4a0411407d75fceb387751c94f05177033cdc3dff580a163f181380b3ea8db82a3bf269b9530ecff227113d44f5f5ade55b7470879704cba59243b1be5cab9bb9f9250994ae5e06f05a55b17276c133d1105a3cfa21e6e4811d269a66929afe8caf4e2db6aeda7259a96ca1e9f05e2b76ad0d7359c37570b10802790f1141c71d3787b34e4c4db25924ec4a173a6381c3adf6d115e4f54083051ef2b6354e445afc7321bb55cf4a729306911bb7ebaa113119945ff5947cf4ff577d5f3a53a35f351dcb919bc62e27a2d062565cf2f6b76c45a1b32f6d076560802ba697d5f30a25097b3bb1815972b6cca23f9ed12c92b22d3ccb89f315bf01abbe513cca079f9b61673f262f925d4eedb7103d30e264d31073242c867f1cf530771728536af8277e0d6cc7dfee0e8e310e6b588f37d93070ec713694e2117775e7f50272ec03425e7ad733de02d660c3dbcc6eec794b1ebcea3b15130cd756ef53987f69aa330ecc16102a7abbfa43ffc1972056e9ff0b2b2b0afcbed019279df5d9e395ad4fbd5d4b6cfef10cfff57d50c4b9b202d0d91f1095b88fad0c3b6ecf3a3013d4c9c677a63c8b037c7e84caebaa4e72caf49271c92fd9c735c593cbd682bbcfe1dc58a8a5fc7f642821f3a94c98701af8102812ce15471049a606f49a254a2da50b4c9af7e61667cd00617cecf38f84f154db05b1302ca8e91c231009879ee9a1be7d43874dbd365938d393df80213207a583df20d68792c86f5cf4a58b227f552a1478c6ea62acb8ebed5cca32cbb21067900381a4aa8de1fd358fadb07523d5c6fb452b86617476483ddf2bb7dfab33c4685d33427717de1bb59564e45b97e06885303a55ae0398bd6802310fd035c4231fe361439c0016c93aa25cc3e9c05f7f654f37f8a32fd74e6e8b7ec27afca8c248be99d1029b5a145659e51308128982d31ea363d404400f8ef557a233ea351497fc48279cbcfef8b9335d7f6a3b6786117a465acbe0d1aadad7220c2c456dc24eb3856be39f71f7747e2e67db5a8768efef9f88c8955ef2d14eeef81db9d95dba0c81520c1141429afec1d9aa49ec66086f29766730be14ed4991048e033b9fde844bc59ecd2969d0b8ed3a98f5ae8ba8ca1ce759209958287bdf74b1979562276c0f8cc856650785feb02ce982f7e09209092f2edf92dc73028b228bf9866b3ac8eef59392404fe386592372b755113880acf51f0046d57f6efa931d3a35b9656fff04ae012ac8367dcd904cdea816d02ed5b74049d449c7f05af4ac205eb09a92e3cf0947897522633abef0b1914200fbe72925a7806b1cef5c7d12accb3bfbf4e2866ad1da57bc6fe91fa6cff877d8f174be55bf7809490e464bfa29a1cb61a898c26e1d4bf67ca4321a2b4a3a807bb6c458a75650a107e02be6575f4c694af867ae3b7dce75f3ec29fcc109b60e00db8e41a008bbc8ed98f8c5a7bff85e0ca4627ddb163f46cb6145f6e1cdfdfef8d49cae0558971dee37a7459a7db3e873c42351c62489356c00f99dc11986de2ac1541c8aca87c42a85b4a7516a895aa46b0face70d0f184e5716a9378b395bf5f8ba089ab137487172a0191a8aa3f7043e5b9e2a809f1ee99b84cff9244787275e5b5345af19fe4a1ba4ae27bf73319d966d772994f685c8d4c869c3ad8d8e6ae7964bb1f485c2b44e827fcf3bf680d65bcdf8572ef374a26b534adb1322e15b1fe9d7e0751e0dc9f728387f84311cc32498070b027ad5b7bacb874d538fe7f12c52f07faa24a5cdd6bb14b2a77392d6a00119069263fe6130b394f02326821d227e43cb1374a9f44535a6edb81db41659b7769e1020dd9979e2503fb1abb7a0693bf48d11006de1f29fe3dc79c834ef9039de3d7c03eb7544a0a5a6d05853a414a591be45bf32ccfbed7e2db35e6f7e68248f78e68cf30167f8fb0899bc66d1b3ac20cf665115cbc619991db8066a335fc6604076e82fdf073a12b3b7b23d13b8270a607adac11e4f9bb0262bd8ce7e0bee072f1bcc045f5f41a208e9a403ca4adb86ef5a446dd628b657e9794143a667bb3813a8daaa4110f3a494d8daf22ca6569f60428047d8847a338de87a82b18e0af47c3d1cc06ff36a1fc5d47dbcbe9eea4b66dbdbcfc0a3142e20eb5219f15a9d439b1b8845c032522d709f382e37edd0c649e29b3a59c952a0baf66e94c266f9c506ab5a727c2ec0d110f7163e43aa3803738e4701c0996b4d57b95de90e61635eaea574c004ac1c9be23bcdc593609200d110e0a6ae0f065662305be27124d1fc57e73a70bc15c7d7cb7f40b5692e29846e4baa64f84158d56917d02822c924ddb3f8610eeb0c7120d3006bdc1908fdf32389871fd6d933ee74ae82ab86a3daba432ff09592dd11c082e95c2a7001db277d6a71874f2b33addbfd5c43d3dd30647dd440ea6c8e105fb8a97e104dc474ad2de574b65252ec4453a9a2591eb46367d9f2f05687b600dbb7baf638605cabf00e1b02866b36d6e0cd9a4d67f587a736874a035b59ab53c996186b62f12e371bf5014e4aba8e553a23352d034644fb8345cee8545fa89e691cb85c12a4d086acf91912e2495df78c81553a2e0577438cdfe71772dad80fbed730da00d98e4f076b15a6f86be06a4165863783fab0b6f9d699206fc3de2e0f0952d13cfa0cdfe9340c486a329887e250736d3070a671e2bd2f07926c676703f1114d8dcc0ad7c53d5ec6cf76320d5f0848ff0b21a659dfe05dcb9fc0c6c0ad06658341bf10bad0cec8224c308b2557a59bb5d4a14f3cd838e2f2e6f5cd0815432ef7923602f8936e03aa7407b6559f68723ad9e01d35b61d3a2e40780d583953fcd365df75cc9eb5ce61c31c9e81074905fe73565e56735cb26180f99739d75ca4f08ed06f0fa1748dbd2648c18cd793f0b2f1c424a0f09c74ccdfdb66c92c2aa33fa9fc3b78489e713e28be180cfe6a682dda35e8cdd3e83fb94fdd9fbbe80eeaa7a57e7ee632902db24a7303cb8f672e317bd4601b8225f61b014b4cda3527a81f0e3ee1d0345c1f2be6d546c7425767d03f40259b77a215e368b7623e13f66c60f3607db6e7705022ece4c94a92685650433bbb9e63c8d317d967cda38835d438398b8ccb09f7cc0c7362369c8ad91e4082d1c4c2dd469e1397219b83c215a8af10c363c0ededb27d18bbbe8289befd92ea1828e5f484343a95f3b3c16a14574b3d5f51a1b13c4b92d3fa62024af3b8dbcfe1dd0b10f19ce987af42dbc3a17df51bab06ce99b1127818a94c811eaff3e4545197f6029df0f9ac65ffbb18587d02c7a5e5f64f0addd4eae191f6fc7de803493718b93ef1457364588b548fc24104da62b3bf958edf1cb7e3b3666bfdb5ddcf379350b5ba957625e4798a57564b626e6cbdf86eaed7799794afe08c9943e3fd1bba0d4b5e7058b15c7dfad82edc3c7d4ae94c0ab61ba0954321b851f1423e92214663dc0ec5dc42a24e3d443120b1ef8ef9d188f84e7028c88f86e82a5ae979692f0b3cfe254dcbe3ca84fe5d1576bdb2810b7a39fa25a054c81303e644ad77f0e3203b69e4c3a30b79585a8f69f5d73397a32ab33dea12f7ee12336f580f68862e4be39b432fcb9068c70912a0e8f24f6cdf269e75b7492731f43664a1a468f0c9ab958d08b64ebeffb0c593a5fcd63c792d84cfaa262f60ad03bb1d63b046e8bdbc5bdf8509fa0c763445d0bb30b3ff205aca334a463f88db9051ca18a1c454b20f5f742fda488dd14e7bbce1bee524ebcaba277a9c78fc6b6bc157d32d405e3fde1c218a6ae6912b72443b4c0574c4ded3da875f9af3dc2a29a02124dd25dff3c542c7189b41f730b832ce99faf5bcc9778b23f3efa416c64d8b42fc68697c82ad55ac658e74cb27baaff4842a186f1adfc8d3e64d381e72386f28d7a098174062b95b25f4a1447efe378e8438ace64180f90319546167c97f7a406453d1cbd95c07616d0d4998a3062ed986f68b5f4f49d54583ed56057793e5bc17ad4793b9436f329443898b7935c8329138a9eea8bc05812eb274aab9fdba444a411bf73452133236d55c5e6b421e1d30749db3e5a349c6b17af2f1b8763e08c3aec0d6e8433be9cb91354251fc27bc9c767b4496220f32b5fff5ad19fedc8d529fd4fe7e678704df73807291a2d5de0ea0b4dbc6a7e718af0df8cb54f5db022a409b86d7402c2143a7daf0d0f5c2f6a4ebdb379c5432ee2776fa9ad1382a0b00f7d22be714db8652a95cd34ec23f0e8c083e452058a71699cc2bb1776039a5559ebe7be5f5671f84e45dd05366f1c8906a9f8008fbfbb1bbb624cb46f5b5a230aee4c9270a8e04186a280d7d4b19bc0bac5f8a265570c0bc2423cb9560b644c2b0d42b6d23bd2b32f2b6a4cc727b51076e419639fed195bd827b8753fe799895970de6a00e6d421bc3e92a998f4c549bb3d3f7e18ed0f1631b036c40381a2e26cdf43de3caf95e0dec3a250c233b9f7d16e626e3f62e73003f957a6d1b3face943b61949cd9dd7b765a7e40096916ef55173b4274d4ccd3027e1363e623965df3944135338281f8d99ca1e0eaa0e0d589a05d82075c1e35828b8695467da18602b7cd1f9871a40de5a9225f00ca68beace9092251679e7ae9e964dd35fc4b918c55f6355f721045d71ed6be925e812a198ab3edc0bd2cc28f0e0dfb7904ee0f1dc2885f39ff4ab4d09a666badbf817b186d8b71042474f9ab7f71918d424760b8206e01eecbfc63a95abf9fc6091fbbc66c1837cae96690d1a2561e833051efefa517527a37f1f921fc58b8c05fca2a5809cb3808ca8d20834fde2495a42a6675b7e1f12a5cfbe52e104a409263142dce91e5d26349bef7ec99f7ca96d00fced3dc45df4a663e2aba114bec13b09b1b257229bce3e63c9e4edd454ba7bd3ee9befa209768901d5d82df42b25efa07d63c329dae724928d3f9e40c9c1908463ee54c5f51c0d92580688a0d3e990b3863f8a4a30995278c311e5ee0e5f916f3965753bd848ad19deff53f2410bc42681c21fa77131ded67e37489e66f8bdffc8013c5308c9321852a66a52c6842c1ad32a8b9479e2f145eb6c26be8531ebab13850243b31b14260d84b514a7d49caf28712c99de331f35242be93f54ee706e99cdae0f4f34648615227c215a3a57cdfc559b96b7e5ed45fb2e6475eec43bfceb5e7d40af812907f4e81a6ba389e00db88ca1c6b1bc2feb4acd560792ca4dc8544f855357493804f9a1d592b1343bc6fd97c81888618953faaae49706a772418fc15e5979ab06b22252a48f7a808030e7e61476e2bcc72613651ebfc9fc0b8e632cab782a29a8e885c87fced68ef837fd19c0065370eaa6b99b04d32a2616385a102fe3126a43ec1bcf83af22cdf85c0c5508cd15258191e73d023aeec569d0016613e44999712f6a1f0946d9c728780ca5de8eca3c9097c529cb92c9759627925b1f1eb39c592854a0d0607082e550c62ab78f26904d92508ce9a2671254b3f64b8a538e4d83f68f54276b1be9c096c15120e5c441c3eb30145a678764a409d77b6eb930b32e7e48288e58a76766d58bf49554bca1be856ed1be679e4e494bb81bcea8b97becbeb268c85a94cf06cf52d2a9a0024d42de745283fd49436da432deb5457d96efc1e3a9fc0ba0bb8a7592374aec9575bebd30c655aca5e48c69280c0098b1f7b2edb3e885a2d072d7a4d389944ff0b1454f1ebcda3d031e8610ec021fa265d564c9c3c15b75b2d9a56575a7514b738f8749e50ea7eb2f983cf74d29df466d778c11cdae7aafc366655ab4d8fbbd69f8ad055e6d6e24d5d6c6dcca25d9dca590cad3e45fc4c22451d47bd6afd7760560ef07f585d27d2e8e14bd9bcff278768f62bfc842cd2c2369c645b6802847d99e73485fef345342eeea8ce83a482a49ed17a6d6fffb15fd478b3f4c1dffb3b6fc17d70c10c80d3c53dee17dc68efe2bde1f36de0eda0ebef86a10c8821089235650a2e37be3560e916424b4e3d1e2b155dec46a498f8a22254b40100282d4a943af62df5385eb0696e75a0a9aabba6aa59ea8aaf94b3be6114bdb97edf210d619c34ecca5c54c5b0d51efbb0c620962b53be8038d6f1273b9437eb4bef022a1abc56fc179f6d0d332577e355e32254644d21c043970b715a8959a5f5adbf9fbe35d2ec6d6bd45f9218af0b52a7ed58e86126321f11f5c0d4dbeb9dc226d378742dc14be4f749f7da1239e264edf21e93d8aba5ef2b4a9ad7c344c1159473468a2477effecb3997774ab9d50b9c14a24836697780d995ee91e3de22e9011967e75764c7c9f5267de5780f487ba4e37de1427957cdd88f2a1782c40c8170f24a9af98620731a4052ca000d84a4c3b6e7f8e3fd9b4c433001bf713f457d053d6597bf26b1e46cb86c594e6d87c3c118234a5c271df9c557c154c15a36cc40892717f87869b71165d8724d552f2d25c049fd345a96d98615d1a9b34ecbb72a1de30039858a6240d87e91dc84f0cb2e2f4d9f6e53a7e4903691ac3a2b98899a22fb5193de99e072656280953c3a33be0417e08c33079ff0271a5c12f24de663c6782fce84668a7cbfa90eec1fa2ddbeec82e3d9f3741ca4978f7ffb4d3e7ae4959fdee69958155e0ca2144af280fa447682d546f14c583e43e41c221a929a184d1ba8ad52ceceb661985fb250722a01092c988f332ce82c6d0b92372793d00ca3b796113dd394419091fb628177d5ce814781e60ea4c83804e4dc202d024ace5afc5486b992234fd50f524c4aa1e206e8bfcca57713b1aa39b902c27148835e4668798dbedfa3d7c3d5693b4901d09c3e1bd6039d9206e2d69e14c271d69e7864ad876e5eda9a77bf7684ce18f6dcfdbde7c6274371113cfc75fb411aa15aba591eabb7ee4e22c4a92518558a3b8af5c0a5e7d75601e38d7cc535d064eb0e6f8ea516eb6c1f51937adf40185a58d333441b43cd2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
