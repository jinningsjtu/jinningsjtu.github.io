<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f722b38413f85d7871258f4ad0364aa8081df0a62d13f20ff033c0a082610d006fe449765cbb44ad44272b0440184aead1b4f382f4d5ece515ea625dec946d4705f8dbb09d244b62c9d99b9774bbd425b4bdfef879dbf0f5ac919f83bfc7e0d57aa5ec325591693dfa25206e2cb8923d3f7ba2a10b54dc5dde1e0d31c88f44322ec36b68b4d2c7a15464b7abb77fd5b2e2335755d9a1cde694977275f06c629386a51c23651dd4bf6d6f586bb9f26d80c0b19a8d47041250781255420de66659490ba36a7382323a8b6092006fd1d0e14e7dfed162fd43bbf429eacdd4517fdd5b668f1bfc205ce8445886c6a0da8d79a6922aeb4a362831d2b768b85ab4e69be8f1e80fbed9ab6b8f56871daf3fb8cffc5deb3beeb4b3a2d5a731f9ca5bb13cc3711c766b1a9756c6072426723e268e0f952def038a99745f969a8718dbebb7316ee9904607047e9a9ad431a480aaa32f7cf0bb0903214d6e7d962ee7e0c61f5046291552905f2dcd3340b014d0c57617daaa310ec8fc2ca71baf6fee4436878c1e573a94d9a0007551cba4311df21c3e92b9cd1ba007c788ac19468a58deef8dbe81f092106cb4db63bc0f6e2c18a0a388470ec0ac6b9a2e4b5267bc5807f3cff178aa5bda434812b9dd03b14e3eac7782ee08a9bd5ab665c1c1b39e3ff2d1bf6ee07edade8b7f0f640748bc556cdedbd44c0403244903fcf1c1ba5de2018d5df4eeba27a3d4fa743bceb146c90ef9a7bd0a68fd9ca5396bba024a52b34a3ba512781f4d82273c7adf68e9299656e5b989183e1c1a530bccf2bcbbe92827649f4fd32893341c0cbc9e199a51f241a0e8f710ed32a12d22ca073550fba5b64ed5733e0c532e51505af103963fa097780567e13c41b31dc52958480a57c43b443df8385782445553fa47a55852b8b2ad6697832113169a5bf795a5718513b810e425daa349a9a8fcff260ccf6f64894e26b4033b11cabac93f2fedd0e62915b98995bb49f51cd8d762fdbeecc42bc2f74c28957579d64a0da2527a20b7031d3efc14bbc6bd2359d81014b716659dc2491868667c8f54bf0ad8ef2a3ac51e6514c63b2be0fcdbcf659bc709a94e2977c085255cc09fc99ef50d0860310775dc2c5608f9a8a9f77c8277830d557664299bbb35b430800ac217897137f4565fa04430c227e0da653b74e323945d0785b850c916ab0f4fb18f91721fdd478c590fe6406be1f3ae3615b2e3c568ffc2d8d50da22f0ec1e8e716fd18fc850a4e61a368d5d95d57b74e4201c002ee4d82980836cdad0a06cc60ccfc3a6da5274b79b4c261f0c0281f7f0445bf46ce703bff56096499a6088f29bbe36f2950fe4e8032456422dbfb5e25d64dfb2923485ea2ccaedc8d97b0770b7da6857312a49365fae56fd3e7df7addd97e1ab5e3687c7df1f8e58abbd025e36ff9e0d309f22886a6a7c20c0718d456e5d0266220cb0a16266487c3b95ffed5e5b3e1c86e727b5a282230de2bd8a2217b66dbf3e80371b233473dccbb469a4295e3366bbb5d4a79df802c6c119175b745cb82f27e0e9902437babee48510e9a5d100346664829e456488f1f969e713dc4a0ac033537e6acad3fabf2e55d9469fda601c91ed10d9614dd21ccdb5bf9cd231a00be835b5b5b4b445d8b118c5dcf202c439d7a7c538d7f465f969ba8cd93c38783d48457f0d695acaa19a974dfe7226ccdf12821f510b0a50f5638316b046617e79c25baa1d1d38511402f16b36c7e68779d55e32e92374b954768beceae8003d3747f849147e28f03c7ad8e0e5aa835c79c1f414f2cb01738bf3d0abedab313d86965937e43355ba2d28141b562a0e148d221d1a894b076b943c4621e99afc8e084c0153950fde44c88985959481449a09d35878193302639e596bb75158cba3c3d5d8d5685fa7c85e8f1ecc49ed29d0b154411c05fde0ad472c8b656b2b151cb6a3b1765664b56e8b1b7bee5a44448d7527612ec987d64219ebd66ecdf26ee3a7cbd4385e78402d4d29b7f84e433496f6d3b6ff43bd357078e92eada3a8f338441061263b6daf098ff6a9c920fd95d1ae02d2983b54dd7ae88d9ad917d87434cf473455a40d70e34f7d4824900cec77e89ad4b1394db1ea706c7380bc533ac854f9c8734a16bdd59892c4848af446faf5fb51276d8f0cd284315f1fbee452b1be19de04e1a30e7e4487ccb42088149a8c6fb9245351f08d37a0fb771e3579ead6e380d226c522897e35ed148a1dc154207ba03162901b89d15196064cae395d70f82cdc352f3d7a33f9a7c791eebaa8ff964dc3431961e64b42a8da79e1c038ea093194b8fbf96deb594391866ff6593aa24cbbc10f25a195793d5b57a6bbe6e8c4f95d62f8ae699f1c3fa064417144c7fa498218acc56c73fc8a326795cc6ec8c776a09e7b63c95080c6763f3d3d96e8dd015865045b8c70033f952cdbbe9dce538f5eba87bcf00ba367b98837019c5d55c80cc51eb7e8cf7f765dd7dee204e5ccf422f9f1717357df422f3d05095326be57844960c2216a58af0a166d58f60ceb86c6c57d0da76de8f3849337dd03c9f3ac633c21c31eb21eeaae45fd75c85cdc21e40d83b952de178ee527114db46e6c685e845246867d560b907441901f81313a10d9666774556331662cc272046338ea18b7dc0fb7044c75f3140e8bb6636f110e889cc772f13c20820d9f9ecc2406199c9739ca20d40d07ffa2095b412bae42866bfc98e74a3486d7119703da4f39279f7ac266697e53ecd0677c68e1f4f6063009297f36943259fd9ed507efcb0dcfb89c91fcd52bffd1756a1ed5e96a519b324daf5528cf22b6e8944a7201417d422e5cfe6cb74f74add49f5d6f3d9ce29a9daf28b3676e987538c8006de3de1e1cba6de24db752b57f8382a0646134f5217848a6fad2cdafd7047c5ee895568f71e1f43ba477a250885ddbae0f02a793d654816989b9bfb1144a514119d471cc01eeb7dc1d066887c26f1ade70888420a3cb8076335fb529bc7425fc4f432658b62a3fc63f5237d49ce5d0f40d012aa1455924150c0c68bc740af8592d03bf04fbe3fda603730ccb181a3f487ece8b9ff2a798fc4ad1b16d030a1c60c04e6b4c14d2c3c3a358ce8e7ac6992582e8c7ed0da0212527d3bc3e74c90a0dda87e66c27bde90e9cb0f3aa2e38ea4f8a4eec4f4e787672f5d13176b7ff4988732fb866d04e86cd2d38a72bd59d87d1945de8d1b2cf8d8a5ba030c66b4da991ec798fbb1f8518ed8020d2dcc991e36bffaae8fea9aa42d0692f768919a98ec269bed19db4f4d18c4583db6bcde0c53f9d38b5290b2b248c11e4ad4ef81cf47e3a5fc164abb346f8d1e89aa547990bba7e2286ae20e4992f2fc21d1ec92628465caad91c377de62ddd8f8835ba45ad1905bc8ef6bf91aae5b5fffac26f8eb614b5b617c73695bc9b0c0fdd0c78b2937ab449c8676665e3e708946a76e59db876f2234eaaa53d1961ae524271f1c823f723541950d5355277d6797c627590db90ec8151714e10e6cb676425fb786c16e719fe0b7e0ca0a6ca7e3a5a52269715bb0e022853b92885eb5970ecca7a17bf099d3799cd36739fc25d6a44db697e2ed2ed166f15b39a78352a8947925424c8b66c05af98446da8a56a8d359555cf54933676515c2c99886cd7bba80f98996323161469c687f9fdb3eb347269e6b43a0c3d15674f8f6eefe440ad798313b616bd4a9be94f665b608de57397fa1e1f864d8076aaf706a87d81f214fadf120e8f86f7ffc8724d366d761ad2c78ba801e69d952885279a6b810e2c36768c446609d9707698b0568c329dd8e77711ff4e0ca082f241105d27a2a87dcf41a46b90812e79312cf4d0fff3333714d351f456f95f3600f571f1c8d15052a156f0bfa7c34c3ed55c6932de0698eb9aadb45572b52ad12bbbe05fb8ea51cfbdbaee4ec80465cf36372e50ca5414785e92bcd9af8f44c45425e93c31960c4e3ded4058d79b6e1668e627ba2d5d24a499670b4f0d8d8985924a7ab89151bba0dfa7254d7ab3d53e66f269aaaee8c0a1bc45731417a539ebd81fefc1749e319ec202d966a53111505940b7fcf5197f142dc524cb93647e7fcb26eb90161f8fbe6632f7a3211dcc6e27da0e5e3c2214a8fbfa4302862088b8cb96e204b7026863d32bdb50483273760f1dad05d78acdb488819247f9ba67198aa9f72ea341112a7ec5c795a8d522a068b53d1936150ae2687dba10a3b3bf8e52062ac21d06d91c6b58f682ea779ab56ba57a8aea4248b5f50d49ceb0af6fe92764a8253c6ceed52d082c9f7ebf5d359e19d6fbea0dec14d47a309e0287c3150bd2fc09d041da58a641f0910036a42a3f50b6703b00df2a61ac936b3841a19dfc671eb678f84c0e918104bbbd6b6a3a6d27499f42d6bb27324c26c58f339133fb40c58b2886cde0e2df71272f2064f845268a9d7efbd6d52b4f16cf33142cb905216b862248cd716ec21e053c753939c1b3a7c0b2c2bceddab26e7c7e3ac798d67274b39d0d1c1c63df641c942f102187ea9fa44098c0ad51e2976c6234cd05cda6ab594a2870d9fe20e9362aff2dd8aac50078df4f94734276e031226ec1b3f09b04ba1f23d0c02c53786e905ddbf294214fe79a5ee01737d379dbaf625809ddfb3282f29639805fbb88bfbef44cdf9d03700e4df0fb2e15a1585e035fd0e1d6dfb60df2a701618249980a355538bad10da923de44e6e57b57cdf20fa02c32135ff41626109697d5e83cafb75e020ee2df5ab5519d7b7b4214d0a8e597f8134586cd0d1f44cd82d8668aa2a367b827bb92993c68e36d7a3069760e06aa93bb69619e4f930f942f82452b32b38f2fd2cc36215b04acc13e93e1d77abd8c14bf3ce5a440480615030d1233abac9c92b892b9438b3139dd9b23a2c2c8a248c77d60ca4117ca5168fc26837259bdbe14d877c9301910174b8ee73565d9f3d2368e3ffe70a7ab1abca8135771b3777a660c67edfb468699494d8f63620ed35e2005aa53c3db8c1648bd5fbb56e8fdc9fbce16a587ef321d39184d6c113292d5056dccc1cf5b4abbcc3185cfee2fff4583a5373e79a1a71e7339853f4c2637bc2daf06977f7c74e6bd9e0faa7e020c668146ccdfb332bae4ec117b1fc5388799c45a380b11fb156e0adb3319d44c7aebd5780e75c2d7edaf4b124645cac870c94f3baabfadd5b3aadd036ae7388c5e26dc1ba2df24a64b5606b318700fcdb5211bb1789ec5fbd5cfeb5b29a31ad15fd568bd09292716af4065f073354737f0dbcf1c44a8af63401a32aa1a10a97873e4723dca5c46ca78287af3635fe61cf3ca803974ea7e44e274ec850ee6738b6fef6d4db479c5a908f911359e53ccb9beacd5b5c46418e9391a1c6df25579092b8617c1fea9cf33a4c47b7d88b2a7b7a539b50f5f4b0d5b1bc7f0b97fe45e7db6c6a84040cfae724b99b207e3b872efede2f6f3ef1a3756656b14bb835c444410a9c05f21462e6d1704681a8ede83fc1a52eb9000d0c7f6634704bf6162912a03b7219b89ba0f3baba4a01edec8f1c0ced4197cf24b59a8bfbcfd6525e7475c84efa3f11da96edbd45a2e7fbd731cb205119937ea31006ee4c052cc9866c25162820ff0b43c3fe7c90da92b491cd2ec8a6747e73aeb0f014867102946ec5ea3dafd24014f9f76d339163cebe621782b326edf61d55482c6939b122cfe645353c19acdaca05e428b64c1b5d6d3a1a1855aabf126fb19f354ddeedd49ac46bbcb3559eb605f6de72de1ad14036d1e5e9b1c5ef522437132e692e3eb472c3dc6358da5f9086f3d47fd74fe2a35a9b8912bb846707948a08d89aca433bfcc2ba8cdf369d5829841bf032b20bf30ea80c52801b6cc347cb9da95186b0d51180c12cb75375c19fb96aeee598a2fb6d9e9ffb90805cccb0b5cc0520e845464cdf7686a8e776490dad32ef7c823d25692565348e0f670fbd8d8057f11919441e500b7bc27467f0c0365c63647f4fa64bf3baac92bfe52cc4f880822f873015d11508b6262a37315078aa5a7a51b3349483346a949d464917a0d367d6222a0641de137be755b881fa2ae551cd9088ab7d2f2aae1d119b5aae74482607447616b1fec78adcb2ed4ed9cc919b9262efadbad38b5868c942240027e2b9218a60bc64ef6d177e64eca9bcc351ad41a62d38878b5bf606b08b5cd1e3c5d38848ee04c9b92969a71bdbbaa446c50aa43c4e4fcde68ee0e6f4c78dbf0f7dfb80a2ff7384ece7e42a1e38358de0ca88cc18ef38d8c23c934df5c1d2526bef19baa08f88eaec9cd5548f1873a8ffae1eed9274f9857dee3841a4ce560684a63a6f70765c24e9c7723e0c4fb531147d5d8582f61bb51a4df4a152b3383a266510f33fbf0872c847723c1337ebcb832a553605d3efbce4a1040e1272631a4affcd7ef3f02aa86d3af46cd291165b0db6cdadc805c6b45bbb782ca62d8cf30ac6272508c49694b2722407a3244af28e5684d6408d71a118dc8132c746c0fe34abc3b4c283eef24062da30f10eb5966d332720c20d9195b16d545caf85143b11031f7a67b773b30b23339c6654181205afd7a31662cddedf637046d3aa06591eeb287da3adf935556e3f43d705cf96e1c4b56e0235cb70ed0a074bad6568248d4dd0b3e5d868475ec36f03ef79a19a2017631a3c1159a2ed25bfcb1d40b63407e1ab1e521f28ab28b352592d5bdd1c9a94d73d6dd59c717f85d4f69695494daf1a5c3096004c5e1f32a148c010042536ebf6a50f6be538a9d7aedaba1799612dc6415424b8bcf35fa4f96bab07f47f5d69feafb078eb9ddb427d5131827d5efd44be7a938dc4453986163f4564dde8c20dfea0333d219f7f766c5a715306209ec47baae658036bc7efa9cc7f2dfff911e00e284bbf241b4120c5b8e45b84711062c4473ba3d7ca177a83f40fbced1eac92d575f4a53e2325b3a3be9706e79725b67e9bee9527bade352e98682a7f1e0c788989aaccf5edcd4b8274e4e106a6b7aae1fd53e6f0041430d243f55c2a16d685f217853ee3ae1d2ba73f91d1c0ef1a3531c229abd0de1eaa69dc3ec99db4ddd6ec3fe0307cfbc1e901a8e94e7a37362071c24222e1b619d0dc099dbbafed23163a56ba1358cd450be84fac52b9707479802181b3a6d4d2afa8fc84cf50fb4345ad6c7033ac42f028d6407e486cd187a7b06584bd62bbd169c90d94d3e497a83a15d90055ad4191652fbdcdf5501650ba1f31f4ef70ea765e66f2c3cd1983d4b294da2a05ee9fea0207d2e9c51afb2eb9158bfd423a3f8aa1470bc75562e672a420a0e20c42fb8ad591cd1cf5924b1afda4e3ae3610942553f49b483b51cb9f6676b794489c06e8cdaac56ad030d2ecdd35d934da020c601cad89134dfa38dd7113a670aa9d2de9b397b8fe7578124ca8674524b8d0665708623d14d513f75b0257f481d3b4a97ccd3b5a2a1803c2095d2e4796287e1b67fbbec38cbb3688500c47c2850c9acd42de8707000d67b43eb53a088a9c278007415c08f70885052f877b7dd43a15dd3c62c158e5acb98c0b589b932fe191873893294411b80c0eb193df27662e20de9cb5431c2c0c49e39f991aa70cc2464f5d22d9da161e315ac49afb03856edcbc0bcaacc64541a0ab78a9e0c167f6ea1a788bae2a36ea6178fb7de81af74189a316ac1cc741d1e9662e6bcfb07417ec6e0c993a60201596c9553d44eee1431521e8ec4072b643ebb9f7710eaa41cdc88066cbce370a2595812e117dfcc70392a97496253e959d412b95ef79f97235596b77aa2c77a50b6e8e042d5fce0bb842bd99e22ca245184304ed498b719853ee15bf30d9ade8e21418d05ad4bc5b0745561c6595f147b854cdf2b5424d668b18222d2a00ccbda85f8a436a29eb4a7e4abc0a4c851f2f0e36d48e0251001578cde4c88785873ae5e6f287e84b5c2f3e90fe5de93b69e8b43317e58bf4345266ccfa61ec51e3b2dd75cbb36596511b51de23e65472249aefcfd7731025be267db6b4fd6255365f92690b63fb554d1b984df1805064eec7cbc63c1a448e4f38ca58a56b147f40dfb3608513799a9446cdc17861a9c462ded766a0bb4211b216fe5b6807a565111a536ccebc66006d9206bdfa06e9df153a8b36aaad6153ff3e595ffd9900b8aac20887960b99c74ee57232c2b47fcbf56e982ae6faade9faa964ccc45b70d5c681b3b531f2d7ff4614520d4baaa3c5fa7c5946ae26d76aed720eafbd78abe772522e92de827b57f626b2d073c72996305800dc90f3a5a9030ed5c9adc8af5e5c8e1104fbb073db3392f2ed96acc8eb8743f95b3615e8d55328c920c40cc63f08a66314fbada98f9caa28570e3daa4e005c7b60e7ec269a75f115e684a372c0263627dddadf9d9c72da51c2fb6926d03eca2f4fc7479666e96e5832d385c428156e7dac0856ebc82c1928c7809c5545c84f8869a4c7055443a97772b7f429e37d353cb0a1f6469959fae3f30fad12765b06a20ca8b8a9ad9797b2838205adb73064471f0e58600dd029055b9d1d16bfca678b96390fbb29d055f294b213985d982da9b29bb6cffdb76bd68f9b9d8fd1665a3a9dead98d17b9f7fcf193abdac35aca70b71d38629fe337595a4b90e9ef72967a2dd7cb4f7c3bf327a584058e95ff42851af227b7d871851fdcd6f3a411d4809a162fc15bc5faff5a02fbc9c4a85416326cc15e95f781d2cae4b0a2a7b48aa095fa294f4061e4834709363c5cce6428e88a320082e453399f303865394ed18d175de77e0911140c99182080cfe636eff343b6fe2ecdeb4c27726d966ee546e8c3ab853827e82ca905fee6912ad11249d862e962d6662f9b2451b93ccf0677a5cfd48b4f68a046dd954598c2388b2f1316a6b929f609dc430171b235387630396d56d11973082c1e2e0257790d02f3c48a1ddff1f9070f218f7365b9df58958f2cf536915beec9910b5cd1962bab78c26c8c8b60f42f83f2d736f409a36bfa42c3eca0f603e63ed23c9cc677aa1732403c50b5958a5587271f8ab82971b4b3bdccc75de49eedc03c4db9172aa7179941e6ed30c16397868affb5144f972c18f23e515045507d0d2ba4104f4c01e4b9211c519679e5e96d14b81f4b815d05d05bccae0905bde3a637e2ea954450b537d2f87ecc0ca9bb2e5a2093f5e2a0e3af022bd5f719b3cca6d765952e878505bb104d035833d9bbe5212db8b7af31a9839cc9cb1e158a7d0f60bd04c35bad4b34c77eb93fe9f12c520f3fed1e9014a34bb59663bc3267c338a3a763e168922e260f0ae911a4088d2ac236e330","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
