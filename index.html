<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5639e2ea97ee193f53d9d4e977d22af6e1e607dbf6c8bd76296300a82d41667385216b25be27b4ab7942f8f0f35a647fc4b43f39b046f1a351262e9479877fae1efdb7bfc9bb500817ceb11ca5ccef6aab0e68a5b88a478ee0f4a41ea54a7bb72e7b2a12b56e661b488013bebff119a344095a8ffb9969fb171f153475ef462acf06ec6fdf5bed3be36a71d7d3955cea0a74bcd823edf2114591fb39cb8f41545f438f0448a6bb995701f2ad532fc356008ca66a13a9844318dabad50611830c797329ba1dd9730ead27aebb7a96241b080014829c8ee598284a1951a1eff60246cd3cc2af434f09a1caf04be84c6835d5c993400efe1d0cde6087448e450c575669961385d281eb55fffff4977e36ca82f54c1de3d046b340e0ab18b6ab8e584d156d62f260664fc897fe5c8d8e96f1ad85ca9a05df30b18cb13169acac75ff23da2d4f7d669d0ea9f6cc0f64060ede5194a4908846921bf00765810b06f1d3b831914136263f05364be682915693d2d99625a69101f29afacb166a9a0b2031c35be860430838f373b61edf2b1f9de1de38048c79fcf219eeb4e0293cef6058fe7f72fe327421ca016962bfbe609fb086e849c90767d68828d14658b6d782893b6a018fd3fc29496b033d863335fc24d66d11f79dd89b0706ed5d9493f40249cc831cd3fb25696620b6ec64a594a4d799714a59b403edd14f432a296074aac19e989efc2c1350ab64c3a705114201c71c70b4e41952b3fa513bbbc1197f644a6c4e7819fb08d5630dc6244ae7c28c2933c2bbc65b8720ba42428397eebaa872de070313e0ccf8e21de002c358bb532d0672b79c2314c214505263f0e067ce69e7bf32cda0ae6db2de396b2d05aa0d20cd3be121199644cd1caea8519f64b51b8bce4694d9c2b92edd3fa3e25d2edafb57f1ebb09b3cdf894ac370fb29a4d4a94a9c5441cd6dde7141c10002e81d0be01607695da3046fcc344b89a22746e6766df714759121294bc8c4cb6db653df56a5c9ef8f96186ebf435bfa5bad42e9ba740e09e6f44ecaa8532b5a22299f398f9e01ccc097bf7b18c5bb5a24f0ac431be3c9f969e64f074ec8cd332167d8dd6511096b3f3dd105e0ed0dc8c909ec83782988d064e305ce02590f35f2052c865e730492cd6d5d6aef4bda0727008f777870222fcd5fcf7ce06c157da9e2c788da6d0f87072bc61c41d1cef1829a14028426e784290a2298a0ee03427dd7c3b0ef3475ea47e4860e3f2c986ca7ee68dd3ca98478c7b6cbfacabedc63da87d15f473122abf52f7f24b240ba4295480ed4f825668339ba39acf9c6b8fb0c733726f405e3045d04071fcfe00c39eee05cf04da29b71d3942296de7ddd8fb5f5d4b572f0977d9d988e6884f61290d85fc182109aa691015586bd8300a9b565893d723b853f1993b2a289a561c52933acbb9b32db5c2a97abd841576f44277f04a4a0ef006bccb29b480ab0a0fd1232309201d33b57fe1f5e3a98b0a8b404f976b733f41cd3eed5d1ac2b6ced573edf68577e8b08c58686294d95ac8e7f42bd7c7e85f79154992f7c8b6fe0552c01417774edb7b48ada38c6a9a78048d8ea9d16f3671d702d4b95d97185d8e1d07c6a4cca70d92c3c04fd6b2a7622aa8a55ada4b184e4242b365b5f2a855768a7523ed1ac0faec0087b274f881bd5683d1d441c35d547b2e6ded18b59ba669b163fb0bc14564f24f52b28a2a387130e2541612eb63d93df6d3da87d034654b7fee9f74dceab660ff80bfe73c9f09b0579640e33fb6931c6b35b555a238a26db89d7db61a08fc3dcd483617072b3b1bb400bd214bd0c03787848eb614fc96d44a47f748bcd9208cd848d64a62263e2ffc40ea4df04e2802642c6507161137bb1f575b4ac3ea7d13a3ddb1df02ffa7483d04330a649d087d1448ee1bdf5fe9ddc70a0639741445ea3c3a081df7ebeb626fb1c477db5da7f93baa3ca9c998dbabcba2cb7e48d803341371fa9af5eb2aa3b8173c5774a4819635c6da16960288d6460ca7bec95dc8c6a3f06c2a0af91cc67c7821ddd2c793e0568a37b89528ff09aed1f8f887303fcaab08b667bc179975bd9b90f2e77a1245feb62f6fb6535000003daa9c1c7bd1aaf763ba6a81caa44c6007f7c68c129037d4f3088a63e28f47b56608abd4f18effc8ad5f321b5a95789428c39734b3e1fbb36331271b95b9a52b2321188e1f34dbe0dd8acdcc07dee8923e44f3dbffb0ce74d78b67177a6c9dac0487d737453e5c64e021f33ee635fc357c4559d6dff35413f7e9f625b3e8b64314e335319b9a822a4e4d5b40eba74fce228547cac3a1649b4e31406f63723d166379c85535c9a261032f51428926b8085f948ff6aac08bf735def7ed9415a1198bc57465055839b5ba854de1dd2ee1d31ba64c15d4f82ffa68df41eb42ff7c5b2af2639f4b2c3a67ba628b144ff7f24643c38dd294991fa287a66101ea878ec037900964fe3c9eaa123b26f724aece62701e77efcda48b6d4337744db1e78e97a4fafc6bb7987fc456c598db8c03e9aaae26fb7e5dfd2ebcda7ee9d44f8495a1f47a419c640fb3907ffc4245d6035c8313d7d4d10511abc56f5ab892a0c869e535d57e71a0093867c6e9c3814785d32a23c2a39010e397b3a4ef6ec58c9a884c7c615a7279036986d3c488085ed3c7863fd32b976227e4527f4253c5ee3222a71ce2af7d1533d90df33241c852b91e2a12e7b670e981e10918ac180b61a4748d6dceb118c5943b28e5e5ab812d4976f0f5a9b21e9428eaf4d9eca1fbdd895b2e62e262985daf8df516c71a4e63730c60b3dc436ad0d1436f7ec457b533810a3ae09f12dbd1bd423a87523dd48c9158a5415a97292d47475cfd9e92d85810872c5dcc1078b16b60daab50f307914120c5ed459c475b7d2c6b21c16ea0d525644bba784c3f0409d0fe136ddfad5548431268da1d5ad5479b083faf07c42440588fdb54954fd055d0f02cd9a738beb2be1b41e9c156abf4830e2c4329d7c9ef665ff4abfa226f7425ffa0c84496a4ae1a125abe52ef689656eeb0c1675ef501e73a9b99768ef96f18e6acbf0ca1164d44ef613820d79405566fd4a99a26a2e1a5c7751ca0398f2185fb08b960bb68234bfde194d970a8efa00e789d1037543ac16f394cd6ce2570dd3dd049a38c922ba2801ffbcabe1e5ccc0ae130c72adbc6f2ac3a896e5699717ea27074e3e8dfe4e33b7075aeb91b5ab5860b21e1bef0002fda4bff1fe3ba3ec5b7416d84b34649de6dd56ecb5f4a8b7d553923ecfb26bc7e7bbe920a5566f59999b59ffa941861b992cbbc2e217c29448bc98a8d2c6b136d7458844ffe9c39e1c9c4790e4756d22c9f663d3cae3e3aed1e0229c9f127302a3ae93c26019d5e735c4883878e272278f9d246f2e8fa2bbc743ac0f4c62f685750c081ddaff30772d4d18577c8d585ee8ec8d88d06fbe1aeef33d2d27b6dff3748c972281fd764862d68a62d60c0cc524dd848982e4d6b12670e4fc182e0fdfb17c8aac405348e0492ff025ef819005bfd5f9c2de5a2bfc11b44c69ef47e8c2ca1d5aa857d0357047b7817be60782d057193ae658f9fd5366a1a6d45ce54d8712c2f985e0acc5ed2f88ce0d75837606c90220ab04899ba847144edf26a17529ba9f7110e51a0041a604151c0dac1de167380641b78b30c49ecbe7660fa5dbd41716369395165442a87329c91e4449310d3abc8de817f66261e7d394fefb2046e5be09ee92dab0716ef3315294bdf4d4621f480be3a459c1b410a4363bf7a713d911c98964ea770a4e2a70d3355c51bff8dd2624514d104ecc3695df0ecf8476709d7e280cce8c5a1d636bc96dda8a9edcb074a5e7239635aa644940040663dba57c1289a076cc6926ce928ed2689129306260259782761207ac79f6ad281d30baa73fdcf8b76afb7e50164fbce2265053433b1a1d7f680d31f05456b6bbec3f795b7462db0a99f4e9a9209762e1eeb6f36dbb5ea2be39b28eeb4b19f54d7d0634f833f3eff2e2f68ff0da3ebf5b9da219f6afdfd2aa39b35a9c537d89652b93d261ac03de5668feb079343bb9bff992ead808ba40d83bfa5bcb8e80c95d4dccca9f5171d99f85055160b1f1a1170747cfe14f741274100ab9bfb855e4aa1e4bc40775511ecab5960da5a0041ba558bbc024efeb2ee43f1d1088fda7fa2e5c5e9ad8b3de32cfc6c2b13fdab02504782c658eee96f1ba5d555920c9b176dad5a00bb0b87949fd17ad1ebc71d2ef8cd00ef2d1967aa679d86293ee7a380eda2fb0753140d554887c4fd0b57bf89b54de144207e6c310e3accda70e90409a8956de66f131dd35d32ca3202f1dee232eb2b1c5483b8d3741d4f0dc18772cd2eb305843b742f453057a9532e10885886a18ef8fb1ba186f905f1648f98b54a542be494161bed0189dc12bbc0412403ebdeeac9f610c7a193c80265ec6f27e699c42558c9f7c01580f5061870550ce104a65ba1dfa270c74785b9f07e07037eb2d45f0a3472975798553f9226e568ebcd44d72ad992357192b69b5181ebbf1e6510786f9c083874a4da6be9fc5f4e75bef86e393352dda771889392882793610a0ac4f06186515ea02f444e1b9a6943982e1b1926188a38817311d8f3187cb25283b3aa4a977d444f9f142e38cc766632a6a14a47056b117a8ef5977856870b806b3db8004d14ca1b5dfba43453279641e4d5f74bd932e2c97a7c05ce32b4ca1571d96b2f861a22368591d84a469758a9c233b65fedee18a5061bc46019b9fcdacfcdee51a3eb242470d75bd851c382d7fd1c79d8bef9d2c415533db4788629b3c58a2fea745b608bd354aee88e705178ed7601332c06b411fd393d342880a3c233e86702dba4ae6435ce34bc5bcb579e1682eefda4720848ca732a8c0d53a3c22ad7a2dea9350b68e02e412e97de0b47f64aadd6195a5e441e8870fc4faaba5233c287c54f236c3bf0e597abc35c1958d5e90e19ed9d801ca3f2c8412b622c459c921e551994210910d7c2bd7405184b04577e905e6d7fc63fdd5043a5d36ba13ea084ddc3e2428f36683df9d4d4e013b53700384036fafc4afbf0d116e199540dc21b5898ba06ed3f80dbe96fde05524713688c29bd2cfe5564e819a3e48516e3b58c95c1c5c5d59ebb60ffe0a41231556cdc60a8f75de0ea1beb32b5b8c7f42100f1499478dffabc122fc2daea215f5656c6e5b7e583ad2a3af974cc2dd2d067aa018907c9f58a89d2f90870084338575699f0ef3332c535d8e819f60c8aa73a7d7bef870dfee8a1aff72528dc76dd0b1c40b6334159c445578292112e5d2b4863bd648f96a4ff343e0157071d6fe0b5c142dcece41d3af2953a4145485a33caded4ed2f2ee4171015b525f95e60ec411c687730a432f68487ffb54bbdb941f4afea935bb128edc57c9e29b86c258b586c27c0e4fa9a866d7d44ec8e66295706ce33f349233bae916b35ac49486cb255155108a3eb9639d3d5000d3679ca672d2d3dbe7adad1c99b2fea46aa01625abe4cb11f1761e13baedb98f5ea2cf632570267954ee5782556178018f4d5381be362365a8572186b2f3f557ec0540a548e90836034e8ab99198c5f14a3529d9ef23664688f06682618362f5161e54969c6524ff63476daa4ef25b81f801e0cdf0a34062b8f68c16aaf12fdacda50cf5cb1ffecca64b6277963e5a3579da96f9c9d9d17c4e2d88e9fbccfe66829738825e04da79220bbe9fde7babd45f65bc7261b785a123d60e8e953ae59343f6a2d7886b0c56b979dcdc12c46d7ca38cd26c32241c1452e312e2b3acb236ce689080ae56b02adaff79364bd0ba135a49f9cd65dc39a8d374dbebd86565900fc2dfe246ec4c427de3a193d99f7889ef46aef4b58fa143995523b4545d4e510512f8524776038177c50724101a52d60f9dcb93acf506966d969c16d2696471985e69fee79fa7823a5d9bb48c2b90e53080c204993f98db8f6020b4288c98e7709293feb2417500170adf70de5f900158e44c61198209efa119bccd9bd4e8af84a57ab6d6662f7e7977e1640c9b0814ee65b37134dccd313765f2b9d7d2f45eab4212e82fc36ac2244d388166b2c10e3d298450e2a3bd96a4bf10e663fe3f575c0ed146070fd0a2667296b6842ef446cf951b1fd4dd4660c0bd8a49c24c1c926d6d7a7ad964b5930da2c87bdf31dadcee8187fbcbbc24e17511c625a1d091529a53f0c0d4b8546780f5912228a4773ed86d93a30d7414e30c35a065dcc816eff6e01e8733ef711b22ee0fb293969139f385c73040ec61829552c9924025c35da26084730acb93833ea4cdf3eb6dc7d47a52b39fe024a6ee27243e700f0eb26c68ec8edaf508a999a586931cb57b9472178108a6cb9237145001adf2ea0c9433a553d3db2d3fafbb419d944a63692975c24a515cbe9bd5fcb4485145d9e03cd200d6ea29cdbfde2f1bf69ceb44f2b3c43854410e8df31b0faa3e782fe5e9fa3d0bcc0e4a178848d37b109ee258ebff02a4f9fcf5e4291ca1d5ac20a5986a3e293f30ea77f4148c4836d246c62d704a7c22287e85d5f4af356cec533a4bac3720788f02bcd7b6e3042fda5a5a6ff46dbe461de75d258dc81f2ae543c996d2af37572713972c374388b5c7fe19ef237e1b55cc33f1c14356c3c72adef8fbe9dd275fd3925f886e32fded820f4b9baa43cefca472fe4d205558df7330549f6f2c6ae18bcb80d73b890d244b34581cae2ab227a08a85f69526f055726ac031102f3c426070f16f59d0cf9a0351b48f870d4d8d162dbe31745a667e68cb133f88995d3341547838d74567fdbc78cdfeeccbde244d117adde5c422d415a0183a6165967d12e7fa0fa6f9449849ff39540838a3c889c768e48db044b1a1f868989b1c1cf639f15cb0771fba5e73013a07b1a607f43c779fdc931989e2102886215912b64348f4ee860b67bed9baa153e2e62f3ea2eee3e423868bb68aa9ff6a8cf47f7abbb6fc82654c5a5237e1172f2607ef761799a4f28ade7f10b03431cc28eb6fed08d68fbaa096331c0abedc4f6f5abf2ce842e10daae87387c2950186cef56603a809e0e277ba4e2c908305aef59cb5207ce73a20575e3fe14f2bef97a2100f8edab38184bde56a84827e385ce212410a7af5684733ea5f524afc3e90e484d17145368d4e7f24788113d8e3470262248d587394c003306ce5e463a714bead1eb495ff69e45304d1df919c7fade6bfb378c91a75dcc220a9f840310cd49618e6a12991e922c2be1ff6780105c78dfa536bab45d5e9e3a9ccd12d7f4000bcbcf1d013f00c49f8731ed6f2caa6cc334b99a9bcd5fb8e13a36353d464d68bd7de59a59627a72673e1af0f4842182591864cd00a320bf2885e76ad19305eea5094f48d830fec1ac70d5d3f04b1e7ea3e438311edf9ba3ab69cf8ad71da3de925bba6afeec7d1c3912b5ef10b7352653c9b84c3104683e26c675e15d460303da416727a4ea073d51eb8ec0fd014a2d6fcf389a23b2191937b5a41569d8ef2a64fa3323564318db21cc6cccbe5b53322583de8c38df08fdc264668d2b0196c5f4021844624ccea14df3e80ca884bd92cb096635974cef4f8fed06f5dc14a25545a0723c9d98941af1e9f01dc004be2f678fdba369d2ca9c6573321071cec4a33780ae5b12ca2d9b48b8694a9196fffc83a9f5834b210091148e5ccdf329cce7400e889ad9dee96035d0ae860d9be0cfc4272a94c93cc72c3bf0ebce836c6d0f0c17134dedae4c5b1115ec5dd2aa7c70ad5b95ef129f2fa0945247f44c4c414706fb5c8d9adaacf72ea6282fbc55adf06f0106368b9d3478d9e84b8ab2aac6315a42aa86045d5940358c14d3546ed68f01aeb8aaa6672accf8bb34114e8f8f6e1ea5d60f6d6863248bb3c3dceb6881737b53e2cbeaf92c7fce5bafc2b946eb7e4366af8e5e0b44022715db98b0cbd3a27fd53c22b9ee62a604a03c8932817224657eb243903cebb72fc2f5b72603ef2091ed85534718c202aa6564a03d4452d1704c05b6aa584b0bf8cbc23c6dd308f6acc21c135104f55277298b1be02cbdb2278af47506559eeb30ffff1e3c3d1fb723f17cc64498c09511fb8e5c5e9275910a26323884b0c011b8c72c508303fcd046bc99891c819c5aa9d6a20fa9b909cb7228d89764120002c28c54729d710c1fbe9502da7de16dd9a2812fac136fe5e26442a34e2e5f41b9ecb47848761ea5233369f647f3cb8f937373e1f120749e995b19ced9b4d660945a2aafc2ee2fa429034c5e1e2f0f4469e5e48f55c67c3ab12e6899006557d85b205e842df3f65339667fa2a28572da65012ee02efb5a5bf2ca14f416829fd56ca3ff1dfd253da6a4e71a314b5385bcc29910d0aef7366606de4e71783ed86d0cc82d9f675dfc34de371db2d0d0e5ef891e343e4315c56f956ac9715d2f7ad6742623170577c4bb7dd7c9ca352a6cbcdbb48548fb19edc08c70b7a28ccbb0eb6754163339bc71701e8632d00e074772d333c00b185201d7cd9389a22f61523a76247674b743cf1a005c07b5658e2fc038a443a53cba0c839fd939db9d0e7a5f3deff6c3fb278924fa6e6fbe40ac37ac0dad8836440931a8fac0912e2d899ebe44a0e87f15ef5dd35a8ad98521580d171d7806df9e51820a8546600830d1d3207ec9726f45e5212fb48035e0d0b42b7d61a3f7275bed182dd82f1ec318ff7886066729e4997bfe0176423aa87f8a2e70e8ee2acc8784764a42ee3a7029bf2cbebe291d542b90d2d73d882a7f4d0c2bdb89c3952407998c317b696cf4b158c7a158d7f6766fad4c331a11e4d15af2c1ec7d336e6716b4bac1a927e9a545c1acc31f6c115d841e4b8676c782024cb88a8b600ef875b51b7a04d6b30eadaf060ed796f00f1fbcda3347f84ff6f0142ba68807d2f584dd00ec784800c737ba2f122b1cee9f6cc9b2dd14d229c6d1b6bc7a62bf5dff81468cbced088ab46106a44b811d80b859e6717a3f8edbeff444e53cefaae0918f812b57af9623e831f5998c22af8f84c50205e27e1dfae8b566c42918457d7d556ff8194f8266202208e4ab903cdfd9b6ae21a0be0cccddf611eb8df2c6756a207bc35beba0403384d2c6eb346271254caa33602d58aec9c2cc6b5ec030f7a5de3726d8ade2eb40663e0a0728362fbd1589be95b09083a5b602d1aa3e7188f82a982eec64dc0c0fe63b5f2688bb918b85b33c8ec2007daf662f8bbfc7ef45a179aa2e0f38f71d836fff2ef6a4430730eebc74413f1ffc56b3a19ee208f5bab6430b98c9b3c39818465","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
