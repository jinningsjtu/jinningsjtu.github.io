<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>Enter password to continue</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3f0c3db9a1aac2d071eb5e4306f3bd6feb56cffe22b1165bbcd2dc9eb2e3f5f4bc3f05c94d9e249ac9bde89093cefd8faa283003c0c41eba0754f55e230f75849613934a68b51d97892a08fb46c8579d38d7fe63b389b33723e6e73da5b3988f4483352a4f466c772b00575d729a5a485dbf996cef57f7fa12d49855fd89ffcc48da0ba531008b1b9541ff3c0807384dbdc14e3fce0232a9c6165f789220334e5ec67b1dde07aaec62c4ed611860377b659dcd3caeee7d37a8119660beff398d4a17dacc416b1b79b5ebab2dad55058ed58eb826be0fdd246985c8737e6da0d041b65fb13e2cd10459b0493e445c5779adb0c506914ed67abeab9465a54fc75374fab4e488b8c4b109c8108d84f2e1a8443c1790e03abfd82258be79ddc5cd8ce887eb6b88df6699c8f2ad7e2d5ea6bf0d654bfc7a56d8b80f3c878a238dece276838dd0b667d588167604fd65a422b21924fc68f3f7aa6172a458d01589942f0aa138dc53223c784ebad6712c941bf1cd4b79a8278077a79dff7aae3aca83bb0db7671daafc66c553b6c88608c04bb1b77a3f3270fdc5134875112aabc4bedf8a484c12e83829a5b14ceca45c9983b130d400b93b412749d1b8ad3dea803472d9cb7baecc013f688e257edc6a5df0ca120ee9a830145be9a8a4e849de890f661efed9263abc881a46662825ede7837065843a1ecc4ad3af38797aa0249c23583783fbf07a67d5a900c585e064637ff83450f4816fb5fddfd69181c172c039cdb976d318f206f872d763422067f1e892389e778bed2746011cd5275eb5c0465ce2112ccdc9cd69f144eb99708469bd4c3c8843431b52241350cbd4008c814983a1e9591015166d97731bbb6574a7c0bc80595b66c7015c82f386c0775133a1ca02ebc022e7c3266d7fdad728586f98a8508cfb343950977fc46afb2ba03f46bdd64c9b599fa05763a0aa27f251fb758a4055f72d64e6212b1cc1e6f0cbdad050346359f945f2cd9d26fb5d31838d31ffa3edcfd0be705c4ea3353091960f6c42fcc71517a6c8ca66786fbbe3c2dc13a09ccdb54b46963ac0fb1b4132f9049d634cf5ad3a9f9adad51a9a1ea7bff387e3f2d5f22448891b42415b7ce80e38239b80b752f3fa44f1e09c76d5425f8b5e8ecfaae057a782e6cfcb048edd9e7dafe8a9cc590a703fd4714e6b3bcabe600081490491a6f7e4a372b6f794a2bb95f9538875a812dd1e5e41079ac95efa780a0933381d3f2d3957204e85d069a0e3b654db446ec17f2b064062f8fccb0e729ba1d70e64dc54b775e3dce1ac785c4e9483ff42179706b4a85b30430be762da8775e6b33566772307e52ef295c8c11d21d0c3a79179ef74633a473c00659a86623daabfc313c42cf6f6842e7baa37c296fca669c0b57a05b6e804f5c855a33237dcd9223abb561a4573828d609735bf9dbcb68edede2286f2323e2ba44e41a872f7e73b4d140cb4dfe6760e921c6b55cf75a0caf10fb91e37a280b46db2c2e7a79cff9c056070813547f378584622d0f74b10d2d61e324e89ea4dccaead59e6d650c41d513abc26ae10d90c733abddb02a5b166af7d623b8348befd7a9afdfd4fb0223df5e4c56d8a9cfc25a6c0a825f060347ad49840faf4a89b09e29114ec18e729b26266ad8fbb80ca0fdc7b18cb9d0ba9340fad4166640600d1b0c93e186d5aea391ced08f57bd8ffd88536fc374715a113182451e65823ded75048fc957c9f1a6acb3402a74e220eafeb651b9a7a5fb5f51dc04f219e7f084a0ed4bba28d76aeb14deeb2eb1f721e445fa78485e0b51ba6cb5fd482a9a39221b1f57f3f5d699415eb955b82c0d9cf32d92bf83e448e4438866adf52cca04e6f2b7f02b74822cfb862bc448c941ea4d8ec6987985845950c76c3e00e14b97e28f6a040cbb3cbf8afedda9751772e7f593c97064001927c4c6099e7aad38aab43e7c447acfe93db53e26676f74edbfec6934e0d69f2a845af6917d4eddcce410431824e6648e320491af308ddb7f18293003ff9cd9da303c1468ce846c6bf225893180874fec01ba601f321c76d0a1973f691e20525531418933cb0b176783da07ab66e1d64a55a947e434ae80cda6add35ce390e75a74da144e6e408cf5b80e11299e07e22f453b7872202dac5d5b6e8a48b1d42fff826cb32f8cd1251d017f380a35c57cacbad00dde6752d4fb88b6c980d935b286ce715f6654a784129a0b07eaef1d4130799a7b88ec450b45b448e679e893f085d4dccc6e9d611b3b0ff24d0c933026c03593587170145004a0aa0e97e80940bbbf403a37cd3521e5bee4e62a1f3b8507f4e4fa8cfa556bb16eb0a8dddc94fdf9c5f55d167af778258fe1ec11df3fdd391dd6613b2386c11b90bdddaa61fa31aaee2fec4e3bee5c70fd10ec6393a8a1abd2ffe5ba71f4f418639daef75c63caa507b0b17002b7dd0f3f297518526a4c39b6a62b1f9d4a7cfbffe2698f4c782ba29d07d83db4ab0062ea0256df52ce5fcb6a48597e2b5631b0d93cbfefb5375b2192f8832294f3e98bd52375985390d7cc52eb8c0aee33b84da2f71a6eaaaa5f1389149d082b3c950356a9b8655304a963897a6bbea53306ea1c8562a3ac639951fc482994ebcca4c130f6cf3665f6f8ec7fc359ff86e2e3e1700e8fcf352e26f6d18ece8991fbc0182b212a3ea8a03072d3756cad3b995835c4a8cf5c257c8131e478c86d109dd8673f6defdddf1b2904f71d005082f0fcc6e2fbe2d2d913866e65acaee8bc0ddc90ce487bbb634ebd37a3abb243ea00d11882fa48d08d0c8eebb059cda2b7571f3e26f47b2a48421f58bce0e9de7ce4f6a20303d8bb4a6859b8585b0bc73110b2eefaebeffde4becae352be93648f7aa8a52889e557837769d054ffd4245aa84390aef1e02680a19ff8c78fb71ede1f7bb542725dff749a0bd1bdd8b2facadec11c954d2e215e82571f43443f606bbc483c7e73109adb402ff93323c9c0b02fac60912789f4b7b2d059d3bb78bccc441aee47ada40bb66b5e8bbdb71ffe8c37d8abf74d01944bf776de0116982015edeece8f2df4249b99b511efb6906ae91c3947b8d3390f9a5ec14e3817d6e4d568aeb1756f67b4134704f794fa6c159f1bf451a8d2878cd945db551288d6e65a30fe7b2db0e2bf790fa0437ce2831b11268a85b48299cea48519965b1e68ef71517a69a4c225813591ebb06202857019d57272332722a1e21649bc57ca242f214ca4492913b9de16abb6c721a932b255daae631cfaf94af5d5821508e13228ddfc3a423b2945ba2406f9116212e35121fd74b1ddb01ff5ae97a0b8ac2d54d823a313f3a1b453cf387b2abeeaeaaff6cc718b1f683b127f7d1092b3d6caac6aa627b2dc7d24d3248def70676a61b7379bd684f5740d8d8518c67a39a2b2dad7b28e9176c87cf4a0929da8f4efb8ca409905c8b749fecdaa152a884f5c7f902095c5bf8c4aca42ec799de0e004e5f4d580647970bdab7a4a381bccb2d162f2429825932d8aa5d961b490a3ec3e19ee75cf0d3186fb6980a9e18f667c73694c81c73cd24c19c12b206e1a4ad8afce309fe09af3e126c279f4e32f937cd779419bd55ff1aaa23d998d09348daeee09d797c2a56dd9b4d95326a3688cd4f232b42a7020c44daa5e1f90239eb901a65e8a3ad4f08a7fce2765b57dea167027776f3798b460198cb15d655b555e3d0519570b1af72b707f1b00e595f709de9490406d95dfe6ef2d7d787e2ec1bccae1211b0d2d7d4f9dcd9e365fd6dc49ade4d5f1b7c1e0ed407050c6adc60edf8685829f06ee47dc27dc74065774629ef77800df2569001617e36ca59ac4ccdf8d4e99dbd6ec4aaf4f2a712ce05052ee2f5dd500f87614bb5bd45f429d350fc70c5d1941bd65261764fe42331e19366da38ec0981410500696b4d5d2014164c5aad3b0a330caf8665d982e93562d346bfcd81fb44152673b3d66d4bf18154946309cf046f212b0e719b52392a46c1a1d281b565321c1d2459eeaf9a2d2d60ae4da2b6aa92eeeaa5eb434c16b5a8989eddd16c19d89680aaeeb7cbb4465423971eca981e77626a9c0c2cfcc628fe7efdce7220519e817988fc35dcbbec894a113fe8b8697b44ec3f161a025b9a93d8a7c86c05861e761f9880fc972d101b74bdd7ed192ebfb4ec212fc5281fe49a644eab10a9be8a988040a959544ed1b179bd88ca55fa0a0a6ea7118b9ceb28fd8b102cf009eed1dd7d55eae21e175d717821a71d5bc7d11f9b8bd836d6c6f9837130edc3dc580667b1f1d5bb5a6f33c41b04de0699196d017e998f328e2439005847b6e3b180a911df4ee3c170673ffb4588cef69ad33ace3e3968f2691c9e37ec94b0f94abc8f19a677e0d4b9f74cf23b8c657cf6290434cbbd8876ae377868b61722197dab332213999478616ba188cfd4a842dbb7724c8b2a899db6021ee90078ff693323628dc7554ab49e415fb5354acb9eab07491b2ee30022a2c9da8ae0f610216188baaa636f494693db6a0d1e1da32cda8bf9a6a10efcb5f1e7f557a64af7eea99b91f06c3e3a66515de3f88671ca868bfb08b3c1a7dcc8c01bdedf0b4d92799e6108f6f075112633450836083cda67a6f4c005f227fa95c7e8afac605a84e8bd4c3cd20392e6c6cf841b3ec0e460adfda952a72bdb25e39f30cf11275f04b5f66b3c83c2d85a51367a312e753537759e2d7c09d6be2cae63b3ac3fc5e260a595992a1e4081e704e02219c648fe173d047ad7aafdee5ae87fcafb25ad072eea1f79043de8148d5be0e003a28a6abeb57981a8dadd0c75ac779cadc6190e51d610266de17a17ff1c7d821c76465d5896f7e139e33ace2f97a31744cba317ae64163e5ba4f76c8cb487e07b17875b1355176d3644e7b7885d6349961e52837f20bf387c3be94eeefa1451e5199271c91f5e17ff1a429e35677f1cfce824d7c4eaf6cd58ea00ad18e8562e4089f5d2c499c77f37895d3954a77e78d19a4116be61c585ce306c543834ad8ee3bb4eff1535924c802fda9eb2dbf26772103ed3ba1d1e3176240ca9aa6492a8df9d7ae643571154d5761c2e07784606be089710e793433b7b5ddc9bf483d1a8d6db50bbb9e7f3a458c1701d318e05e15e75c283167c4b8f286b00bdfd4786440633f1979e4b3130e7032dee9faeed7a30f9a38288e5749c5350c14e72d4b4b44d0555556ac77e97a1a3f6362aa259be74e8953ec5ad3d32d8df965d9cddc2964e53d04a76bd210de8c6a9926e5631ef0dad5b5122345604791bfab47e1020c238d931859881d859fdf89dd595b34a379efcadf895157b7998b4e85c4a7ffae28b0123fa2f4e70d7c49cc45a05f0b3c3953bfccbe87b95af143cc547fedc3edc4e634c2cb88afe3c740aaba006dd8cba61ee441cd3facdc5639ad41b22de309cb63977b975874cb0302823e38c8fa317ef48e1be6a79eadfba60664ffe2b9ce2c18bd7a9a7193539ae5f1d1c922902ebbd3f43d225c5ea03d98bea8036ba8c6c3cc8549eab91b4a611de1f302f44b75af161c5bab54b3f5259dae40831768ddf0b2b93d6b3f18f36b62c27d5d945aaad16be584590f91cd4355afe83f234cb8c2d99cf07aab36651bb114e6c1c61dfb1b3d1af3928c35842f75ea80807344db16bbc2fb653655b9ce9b21c03d567e7db810c503ca2b81bd0b595cde78291ea6daf6b86bcd832dcbb142a7b79a502321af448f18d4685b38f27baf10ffc28e06fb6f80a9d23ee61d7bd0420cb1ff00c839a7c2b6d37f5df22ba119fcb3cc3355b409dec58cbb96403b03109ad380e7fc102d814956e1cad5c1ebcedc43184baf935132641a5db44abb637855bf7ac64287334bca15241a892da9b362abc61539a8c16968ad48a191075577e13046df24e85da8ce5d73a453d86a8d85256af5fb9a283f721107d94cff08b9f9d7fea236fd570efed1e0ca378db6768e14485bf32c4f2625ffefaf5667b176cd538fa9298ebfb519f0ff3cb3100014750ef57249e71c0c1d4cb931b57352fdcfd22ad138054fe7b70457eeb229f3bdceb80978bddcdb42fe8657e50a3bf0d09e593771073ab0b90174b3ffe46fa701f8fa2fe96c48a9cc132fa06dacc6f9ee17b5f4e3879c252790a4466f89d10e9ccee2c1c23331b0fbce2564a8f74a70c52972cef1f613a53a74c0e1d5db3dc46165126c26f435404b0b3d6b80bd67c75e2321e9332ffb6caee1694639a1079ae77f82b7e54ddbc7b6ccc3936023a660e0338d7e2bd4bcc7ec533d5b9770e73b1b412d93dc5cddd05550eecddddec954c6dc8666993655e1c2f87e8e8d26daf6c3d1d3cd6c1fc14a67ab21ba76b20d4cce6a5792dcb947e053872f34ad170af44e2547e268a76cb2904c3fb977bb7b78d835d9e554f6cc7aca7cb2a8d521213953c4af13d9dd5d96edac07951af82c0e6f48fead1a6234ecdcb71cad68bd8d124a17b55ee72dd26d5a3aeceb6c874231bc233b0e09d9da580bd0357298d8fa764eaf5b4445fca16ef0f6e0eff0a4335fcf36b6285d21dded50f54150c0936920c30b521abd30106bb68c0fce5451d156d5d1d8632f821cfd2ac6d95797a7ebec04d3dc07203d7b2237cc56664987434949897d6c5a7249d44f604f75332ef1f2015d730c2eb68f11feb3d1ec4c0eaaad203b532e31d010fb2e31142fdd360e7e3bdfbbff477e261ff28d95974c9934cabbd7d45bd06120ab3128ca01d389d1b69c586d5309624bcdd7f608b4c92f657a5fcbcb38545662577dd233e68557d5294b441464dc5f7eb79b927a22705f4e3dea40566283207ba9c6c9f87dd9d8a3643e5fa9a5e691b71d1640fd17d384a58e5cc7f43e9f5722a740c3e1af4cbbc4b8cc33ddbe87bd9d1e4310ddb1c3b2a8f7a7763de4b21ca26426001e5852f2323286264eaad8bec60d3c8e4a570532ed4200be93158c4d426eceee0b23ea76eaf2c12499c3762ea52b46646859dcddcf287b9ec5fa54edd25dbd0c0d228ed94eee116c6a51b316be7adf253c70ce7f268de9b51b286799387d6a5f822d9d7249bb8b83a212d96e12c13bed7c1785547bdc3bb9882d612750faea2cc7b76a1a4e08095caef974a612716965034549643118442d444871477f89e57ac277801c01f77bbe1e3f70b054ca1dfac5a5179eac2a954536f39c64053cafd22f4b2109490307d11a7f72a085093e182a7a3b2a8aa3d6229c1bd70586227918ea804feb0f67281d289e07d0ad1dad1f3bab83967bf3d7652020c4cc837fa73985d4a38854474d74199591f44dd5bd3cf7655ff6a6e0bdcfa8f8e37fef004099bea103c028914d8da3f3694ef27eafde7feb29d60a9e55b30746ee11dcddf9331b462ce1c8e0c1ce320ec793039ccc0aaebd5a18f08f48215e345fc8495298f71ef27901f0accb939fd512911577962ce9cdd721500317250d4613a48303bfb2d2b6ed136793fea60a1d50f24d439f6a709cc9fc7d39a0cdf8a9ec513f2c3acbb36b66fcd320377e6d742a2b4aecd4f5a35b0d8974f2fc69f0bf4d3c1c146cc47b294e9a9e5ee8cb81dd3c76e1800614a277552f3798295637d9bafb80de929370fce6a69dc7bd2b6ea0e5934e7bbba368da64b305599d10ffbdb21e8b975eaa5ee383daf01c146cde75b3bd1d146607b6f7c98c626eeed63db0fbf42a55133301759e3b22531b8f7c599247e0a1f8caf10e94ce33bb668cc9f70844eaa194b1ab535f69ebe86fef308e513b5b9841d8067f43f913d878f221ac473a6dd1f35465d38d3e20eb7b1f03f5d22aebe91a67c3fe216aedf76abe1870a32bd775fe7c76954b8b71f907934c1a929c6630e50ea090ed13c3cffa67d56b2a2fcdb3a89479ca0b7df6283a616f422e41ff77b22832292f6f9c1824ff4231bf0459d1d9adb14d85f37a8a84e2a4d563bef6bfb84ab9ae8388ac815c38acfc8756f3361512b723fecae70b8a15f82dbf35f5d64ee5c03cd643ca13d8caa48f9ad01ae9fb4c48b432f42569d6cd000cf4dd249133a793591a487c5a5527c279ad19c8ce0144ec3e5c1ff0efe384b8db8427adbd6852a954283fd7c7958f9cdd6525d14d910b19cb899ac6b89b5a92e6a1b30c433a193135d704e15c8e0346e82759375e9fa03fcd85cfd840f424d505dd3f8a4f1bbd2d220738c7a057803b050edfc6ea8eedd6967b05abfa8119c2cb8ccb6f98cc36dbf948fec37b55c4f8700637bb8c20cecae35ec1198d2da0c8d21090e8e1a728916e95362a6060662ed34270ad40a1383badc4267123cd194616d1e794cfe19d39afcfbd829f62ad8f692b896be12928194ba6ba5599b11ee010b79e7cb251db08a8af079a9fd4d05ff2d4ad5306e31c4ab6d9630b898e2f07623afa80694cd04276becd92f2f583ef6e1772ba2f01cec5e6f17584ee573928a0f915f7314e1597592a38a4da2bd836975d88141981207d6575c33a354db4d0770c969846936cf4f779b8c3b0bd1415399d4bef025b830067fb2be63bbdd9eff8b80f38243f1da96dd1ee13fcdebb459a05ea6a67048de10fca370590b9ef5c0285b9de5b8b0115d9275ece350375057b9033323783606b9990b37cd890502e73ef8d17c28f3a1f047ec3cb054fcf2eed4c01c9a383b61833964e0774393719ef69591edd5d539deb0fda9957292cd675eaeb42f846be242db54432451dd500fe8224786ead6f734b8e8decb45a710ac0f498c77e478da05868447c334760c7e9f088d6307ee31336f526d06f238fb4903b765c13ac14d89abb4b36c737b929ebd9ef00fe24da235b40d306641efb419c3059d8de9a0e9ea1dff3410f88589d2b319377cf42d9d70a563feb22258b931c4ebb6239a9d258e163d0fcfb907c99ae0b6b52dc8fd69b3da403f4a2030b77f446ba910b3628af1326405fb84a17eee2881a97bb9add6fcdca5eb143a87b2384803eb2a83c804fcfbb884082d6c790ca9c57430f3ac93635ac4912ce3c19d7eadcf73a5ad356959ab0eb64a0899501a4f68195ccbea70a17798f5b720c516eb581a630534304009aa78d4c532dbd665516dd7cac7412c39040852a828d99d1761da915f99015f802d7b7fcb2ce2f6619568a672580afc2339556645ef54f109e76d5548fa6cae947dddb75347f96d48f16aa27ecd238fb6eda356a832089899c3d1a1cd9f68037f35709bc273ba514a092031cef157168d56971a44baf3dabdbc7edf7c3647e448677d60340c1b706f271fe8a09f9f6a9fb7ee0880f9a1e889a20671fd7202c95eb596fc6879982063b2f4a2ae82a1d7d98e1c30fcbbbc86a3c3844b5756203194c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e261406a067d525d8ed7dd29b110cc20"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
